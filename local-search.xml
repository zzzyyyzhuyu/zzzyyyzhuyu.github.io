<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LinkedList类探究</title>
    <link href="/2020/11/23/linkedList/"/>
    <url>/2020/11/23/linkedList/</url>
    
    <content type="html"><![CDATA[<h1 id="LinkedList探究"><a href="#LinkedList探究" class="headerlink" title="LinkedList探究"></a>LinkedList探究</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>实现List、Deque接口,AbstractSequentialList</li><li>基于链表实现，内部维护双向链表</li><li>便利查找效率低（链表），但插入删除效率高（链表）</li></ul><h4 id="Tips、"><a href="#Tips、" class="headerlink" title="Tips、"></a>Tips、</h4><ul><li>修改效率高，修改情况较多情况下使用</li><li>默认容量大小为？</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;    <span class="hljs-comment">//头结点</span>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;    <span class="hljs-comment">//尾结点</span>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//根据指定集合 创建LinkedList</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;        <span class="hljs-keyword">this</span>();        addAll(c);    &#125;    <span class="hljs-comment">//根据当前参数 创建结点，当前参数为头结点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-comment">//创建新节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);        <span class="hljs-comment">//头结点指向当前节点</span>        first = newNode;        <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">//之前头结点为空，说明是空链表</span>            last = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//不为空，则将之前节点的前驱指向新节点</span>            f.prev = newNode;        <span class="hljs-comment">//长度增加</span>        size++;        <span class="hljs-comment">//修改次数（版本号）自增</span>        modCount++;    &#125;        <span class="hljs-comment">//尾结点插入节点    </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">//尾结点指向新节点</span>        last = newNode;        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">//上一任头结点为空，则说明链表为开孔，头结点也指向该节点</span>            first = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//不为空，则将前节点的后驱指向新节点</span>            l.next = newNode;        <span class="hljs-comment">//长度增加</span>        size++;        <span class="hljs-comment">//版本号增加</span>        modCount++;    &#125;    <span class="hljs-comment">//在给定节点前驱插入节点</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;        <span class="hljs-comment">// assert succ != null;</span>        <span class="hljs-comment">//给定节点前驱结点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, succ);        <span class="hljs-comment">//给定节点前驱指向新节点</span>        succ.prev = newNode;        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">//原前驱节点为空时，新节点即为头结点</span>            first = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//原前驱节点不为空，原前驱节点后驱指向新节点</span>            pred.next = newNode;        <span class="hljs-comment">//长度增加</span>        size++;        <span class="hljs-comment">//版本号增加</span>        modCount++;    &#125;    <span class="hljs-comment">//去除头部节点（内部方法）</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;        <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span>        <span class="hljs-keyword">final</span> E element = f.item;        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;        <span class="hljs-comment">//当前节点置空</span>        f.item = <span class="hljs-keyword">null</span>;        f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>        <span class="hljs-comment">//头结点指向当前节点的下一个节点</span>        first = next;        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">//当前节点为空，尾节点也为空</span>            last = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//节点的前驱设为空</span>            next.prev = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//长度减1</span>        size--;        <span class="hljs-comment">//版本号+1</span>        modCount++;        <span class="hljs-comment">//返回当前节点</span>        <span class="hljs-keyword">return</span> element;    &#125;    <span class="hljs-comment">//删除尾结点（内部方法）</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;        <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span>        <span class="hljs-keyword">final</span> E element = l.item;        <span class="hljs-comment">//获取前驱引用</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;        <span class="hljs-comment">//删除当前引用</span>        l.item = <span class="hljs-keyword">null</span>;        l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>        last = prev;        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">//前驱为空，代表头结点也为空</span>            first = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//前驱后继为空</span>            prev.next = <span class="hljs-keyword">null</span>;        size--;        modCount++;        <span class="hljs-keyword">return</span> element;    &#125;    <span class="hljs-comment">//移除任意一个节点(内部节点)</span>    <span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;        <span class="hljs-comment">// assert x != null;</span>        <span class="hljs-keyword">final</span> E element = x.item;        <span class="hljs-comment">//获取当前节点的后继</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;        <span class="hljs-comment">//获取当前节点的前继</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;                <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//当前节点前驱为空，移除当前节点后，当前节点后继为头结点</span>            first = next;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//前驱的后继为当前节点后继</span>            prev.next = next;            <span class="hljs-comment">//当前节点前驱为空</span>            x.prev = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;            当前节点后驱为空，移除当前节点后，当前节点的前驱为尾结点            last = prev;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//后继的前驱当前节点的前驱</span>            next.prev = prev;            <span class="hljs-comment">//当前节点的后继为空</span>            x.next = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">//当前节点设为空</span>        x.item = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//长度自减</span>        size--;        <span class="hljs-comment">//版本号自增</span>        modCount++;        <span class="hljs-comment">//返回当前节点</span>        <span class="hljs-keyword">return</span> element;    &#125;    <span class="hljs-comment">//获取头结点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">//空值校验</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        <span class="hljs-keyword">return</span> f.item;    &#125;    <span class="hljs-comment">//获取尾节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        <span class="hljs-keyword">return</span> l.item;    &#125;    <span class="hljs-comment">//移除头结点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-comment">//非空判断</span>        <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        <span class="hljs-comment">//移除头结点方法</span>        <span class="hljs-keyword">return</span> unlinkFirst(f);    &#125;    <span class="hljs-comment">//移除尾结点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-comment">//非空判断</span>        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        <span class="hljs-comment">//移除尾部节点</span>        <span class="hljs-keyword">return</span> unlinkLast(l);    &#125;    <span class="hljs-comment">//在头部增加节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-comment">//连接头结点方法（内部）</span>        linkFirst(e);    &#125;    <span class="hljs-comment">//在尾部新增</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;        linkLast(e);    &#125;    <span class="hljs-comment">//判断是否包含</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(o) != -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//获取链表长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size;    &#125;    <span class="hljs-comment">//添加节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-comment">//在尾部新增</span>        linkLast(e);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//删除某个节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//为null时候情况</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;                    unlink(x);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;                    unlink(x);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//从给定集合添加全部节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;        <span class="hljs-keyword">return</span> addAll(size, c);    &#125;    <span class="hljs-comment">//添加全部节点具体方法（index节点前插入）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;        checkPositionIndex(index);        <span class="hljs-comment">//集合转换为数组</span>        Object[] a = c.toArray();        <span class="hljs-keyword">int</span> numNew = a.length;        <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//获取当前要插入的节点</span>        Node&lt;E&gt; pred, succ;        <span class="hljs-keyword">if</span> (index == size) &#123;            succ = <span class="hljs-keyword">null</span>;            pred = last;        &#125; <span class="hljs-keyword">else</span> &#123;            succ = node(index);            pred = succ.prev;        &#125;                <span class="hljs-comment">//循环插入节点    </span>        <span class="hljs-keyword">for</span> (Object o : a) &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E e = (E) o;            Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)                <span class="hljs-comment">//前继为空，当前节点为头结点</span>                first = newNode;            <span class="hljs-keyword">else</span>                <span class="hljs-comment">//千集结点后续为新节点</span>                pred.next = newNode;            pred = newNode;        &#125;                          <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//succ节点为空，当前的节点就为尾部节点</span>            last = pred;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//当前节点的后继为succ</span>            pred.next = succ;            <span class="hljs-comment">//succ的前为当前节点</span>            succ.prev = pred;        &#125;        <span class="hljs-comment">//长度修改</span>        size += numNew;        <span class="hljs-comment">//版本号自增</span>        modCount++;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//清空当前链表</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//逐个清空节点</span>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; ) &#123;            <span class="hljs-comment">//获取当前节点的后继的引用</span>            Node&lt;E&gt; next = x.next;            <span class="hljs-comment">//当前节点置空</span>            x.item = <span class="hljs-keyword">null</span>;            x.next = <span class="hljs-keyword">null</span>;            x.prev = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">//x指向后继节点</span>            x = next;        &#125;        <span class="hljs-comment">//头尾节点置空</span>        first = last = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//长度置为0</span>        size = <span class="hljs-number">0</span>;        <span class="hljs-comment">//版本号自增</span>        modCount++;    &#125;    <span class="hljs-comment">// Positional Access Operations</span>    <span class="hljs-comment">//获取当前下标节点的值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//是否越界校验</span>        checkElementIndex(index);        <span class="hljs-keyword">return</span> node(index).item;    &#125;    <span class="hljs-comment">//给定下标链表设置为给定元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;        checkElementIndex(index);        Node&lt;E&gt; x = node(index);        E oldVal = x.item;        x.item = element;        <span class="hljs-keyword">return</span> oldVal;    &#125;    <span class="hljs-comment">//在制定位置新增节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;        checkPositionIndex(index);        <span class="hljs-keyword">if</span> (index == size)            <span class="hljs-comment">//如果为尾部，直接在尾部新增</span>            linkLast(element);        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//不是尾部，则在当前节点前新增</span>            linkBefore(element, node(index));    &#125;    <span class="hljs-comment">//删除某个下标的节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//边界校验</span>        checkElementIndex(index);        <span class="hljs-keyword">return</span> unlink(node(index));    &#125;    <span class="hljs-comment">//判断当前下标是否存在</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size;    &#125;    <span class="hljs-comment">//判断索引是否越界</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPositionIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= size;    &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Index: "</span>+index+<span class="hljs-string">", Size: "</span>+size;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!isElementIndex(index))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkPositionIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!isPositionIndex(index))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));    &#125;    <span class="hljs-comment">//获取当前下标的节点</span>    <span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">// assert isElementIndex(index);</span>                <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;            <span class="hljs-comment">//在左侧部分，从头开始寻找</span>            Node&lt;E&gt; x = first;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)                x = x.next;            <span class="hljs-keyword">return</span> x;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//在右侧部分，从尾开始寻找</span>            Node&lt;E&gt; x = last;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)                x = x.prev;            <span class="hljs-keyword">return</span> x;        &#125;    &#125;    <span class="hljs-comment">// Search Operations</span>        <span class="hljs-comment">//获取当前元素下标（从头开始找，首次）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//为null时循环判断</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> index;                index++;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//不为空时</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (o.equals(x.item))                    <span class="hljs-keyword">return</span> index;                index++;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;        <span class="hljs-comment">//获取当前元素最后出现的下标（从尾部开始找）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = size;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//为空时尾部开始都查找</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;                index--;                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> index;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//非空时尾部开始倒序查找</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;                index--;                <span class="hljs-keyword">if</span> (o.equals(x.item))                    <span class="hljs-keyword">return</span> index;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// Queue operations.</span>    <span class="hljs-comment">//队列peek方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//返回头结点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Retrieves, but does not remove, the head (first element) of this list.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the head of this list</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NoSuchElementException if this list is empty</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">element</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getFirst();    &#125;    <span class="hljs-comment">//队列poll方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//头结点出队列</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkFirst(f);    &#125;        <span class="hljs-comment">//删除节点（删除头）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> removeFirst();    &#125;    <span class="hljs-comment">//队列offer方法（尾部添加）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-keyword">return</span> add(e);    &#125;    <span class="hljs-comment">// Deque operations</span>        <span class="hljs-comment">//首部压入队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;        addFirst(e);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;        <span class="hljs-comment">//尾部压入队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;        addLast(e);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//获取头部节点值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : f.item;     &#125;    <span class="hljs-comment">//获取尾部节点值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : l.item;    &#125;    <span class="hljs-comment">//头部出队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-comment">//不为空时头部节点取消连接</span>        <span class="hljs-keyword">return</span> (f == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkFirst(f);    &#125;    <span class="hljs-comment">//尾部出队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-keyword">return</span> (l == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : unlinkLast(l);    &#125;    <span class="hljs-comment">//push入队列（头部入）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span> </span>&#123;        addFirst(e);    &#125;    <span class="hljs-comment">//出队列（头部出）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> removeFirst();    &#125;    <span class="hljs-comment">//移除首次出现节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">return</span> remove(o);    &#125;    <span class="hljs-comment">//移除最后一次出现节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-comment">//从尾部开始倒序寻找</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;                    unlink(x);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-keyword">null</span>; x = x.prev) &#123;                <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;                    unlink(x);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a list-iterator of the elements in this list (in proper</span><span class="hljs-comment">     * sequence), starting at the specified position in the list.</span><span class="hljs-comment">     * Obeys the general contract of &#123;<span class="hljs-doctag">@code</span> List.listIterator(int)&#125;.&lt;p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * The list-iterator is &lt;i&gt;fail-fast&lt;/i&gt;: if the list is structurally</span><span class="hljs-comment">     * modified at any time after the Iterator is created, in any way except</span><span class="hljs-comment">     * through the list-iterator's own &#123;<span class="hljs-doctag">@code</span> remove&#125; or &#123;<span class="hljs-doctag">@code</span> add&#125;</span><span class="hljs-comment">     * methods, the list-iterator will throw a</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> ConcurrentModificationException&#125;.  Thus, in the face of</span><span class="hljs-comment">     * concurrent modification, the iterator fails quickly and cleanly, rather</span><span class="hljs-comment">     * than risking arbitrary, non-deterministic behavior at an undetermined</span><span class="hljs-comment">     * time in the future.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index index of the first element to be returned from the</span><span class="hljs-comment">     *              list-iterator (by a call to &#123;<span class="hljs-doctag">@code</span> next&#125;)</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a ListIterator of the elements in this list (in proper</span><span class="hljs-comment">     *         sequence), starting at the specified position in the list</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> List#listIterator(int)</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        checkPositionIndex(index);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListItr(index);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;        <span class="hljs-keyword">private</span> Node&lt;E&gt; next;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nextIndex;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;        ListItr(<span class="hljs-keyword">int</span> index) &#123;            <span class="hljs-comment">// assert isPositionIndex(index);</span>            next = (index == size) ? <span class="hljs-keyword">null</span> : node(index);            nextIndex = index;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> nextIndex &lt; size;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;            checkForComodification();            <span class="hljs-keyword">if</span> (!hasNext())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();            lastReturned = next;            next = next.next;            nextIndex++;            <span class="hljs-keyword">return</span> lastReturned.item;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> nextIndex &gt; <span class="hljs-number">0</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">previous</span><span class="hljs-params">()</span> </span>&#123;            checkForComodification();            <span class="hljs-keyword">if</span> (!hasPrevious())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();            lastReturned = next = (next == <span class="hljs-keyword">null</span>) ? last : next.prev;            nextIndex--;            <span class="hljs-keyword">return</span> lastReturned.item;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> nextIndex;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> nextIndex - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;            checkForComodification();            <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();            Node&lt;E&gt; lastNext = lastReturned.next;            unlink(lastReturned);            <span class="hljs-keyword">if</span> (next == lastReturned)                next = lastNext;            <span class="hljs-keyword">else</span>                nextIndex--;            lastReturned = <span class="hljs-keyword">null</span>;            expectedModCount++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span> </span>&#123;            <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();            checkForComodification();            lastReturned.item = e;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;            checkForComodification();            lastReturned = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)                linkLast(e);            <span class="hljs-keyword">else</span>                linkBefore(e, next);            nextIndex++;            expectedModCount++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;            Objects.requireNonNull(action);            <span class="hljs-keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;                action.accept(next.item);                lastReturned = next;                next = next.next;                nextIndex++;            &#125;            checkForComodification();        &#125;        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (modCount != expectedModCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;            <span class="hljs-keyword">this</span>.item = element;            <span class="hljs-keyword">this</span>.next = next;            <span class="hljs-keyword">this</span>.prev = prev;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">descendingIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DescendingIterator();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Adapter to provide descending iterators via ListItr.previous</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DescendingIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ListItr itr = <span class="hljs-keyword">new</span> ListItr(size());        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> itr.hasPrevious();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> itr.previous();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;            itr.remove();        &#125;    &#125;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> LinkedList&lt;E&gt; <span class="hljs-title">superClone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (LinkedList&lt;E&gt;) <span class="hljs-keyword">super</span>.clone();        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a shallow copy of this &#123;<span class="hljs-doctag">@code</span> LinkedList&#125;. (The elements</span><span class="hljs-comment">     * themselves are not cloned.)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a shallow copy of this &#123;<span class="hljs-doctag">@code</span> LinkedList&#125; instance</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        LinkedList&lt;E&gt; clone = superClone();        <span class="hljs-comment">// Put clone into "virgin" state</span>        clone.first = clone.last = <span class="hljs-keyword">null</span>;        clone.size = <span class="hljs-number">0</span>;        clone.modCount = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Initialize clone with our elements</span>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next)            clone.add(x.item);        <span class="hljs-keyword">return</span> clone;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns an array containing all of the elements in this list</span><span class="hljs-comment">     * in proper sequence (from first to last element).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;The returned array will be "safe" in that no references to it are</span><span class="hljs-comment">     * maintained by this list.  (In other words, this method must allocate</span><span class="hljs-comment">     * a new array).  The caller is thus free to modify the returned array.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;This method acts as bridge between array-based and collection-based</span><span class="hljs-comment">     * APIs.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an array containing all of the elements in this list</span><span class="hljs-comment">     *         in proper sequence</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;        Object[] result = <span class="hljs-keyword">new</span> Object[size];        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next)            result[i++] = x.item;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns an array containing all of the elements in this list in</span><span class="hljs-comment">     * proper sequence (from first to last element); the runtime type of</span><span class="hljs-comment">     * the returned array is that of the specified array.  If the list fits</span><span class="hljs-comment">     * in the specified array, it is returned therein.  Otherwise, a new</span><span class="hljs-comment">     * array is allocated with the runtime type of the specified array and</span><span class="hljs-comment">     * the size of this list.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,</span><span class="hljs-comment">     * the array has more elements than the list), the element in the array</span><span class="hljs-comment">     * immediately following the end of the list is set to &#123;<span class="hljs-doctag">@code</span> null&#125;.</span><span class="hljs-comment">     * (This is useful in determining the length of the list &lt;i&gt;only&lt;/i&gt; if</span><span class="hljs-comment">     * the caller knows that the list does not contain any null elements.)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;Like the &#123;<span class="hljs-doctag">@link</span> #toArray()&#125; method, this method acts as bridge between</span><span class="hljs-comment">     * array-based and collection-based APIs.  Further, this method allows</span><span class="hljs-comment">     * precise control over the runtime type of the output array, and may,</span><span class="hljs-comment">     * under certain circumstances, be used to save allocation costs.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;Suppose &#123;<span class="hljs-doctag">@code</span> x&#125; is a list known to contain only strings.</span><span class="hljs-comment">     * The following code can be used to dump the list into a newly</span><span class="hljs-comment">     * allocated array of &#123;<span class="hljs-doctag">@code</span> String&#125;:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;pre&gt;</span><span class="hljs-comment">     *     String[] y = x.toArray(new String[0]);&lt;/pre&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Note that &#123;<span class="hljs-doctag">@code</span> toArray(new Object[0])&#125; is identical in function to</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> toArray()&#125;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a the array into which the elements of the list are to</span><span class="hljs-comment">     *          be stored, if it is big enough; otherwise, a new array of the</span><span class="hljs-comment">     *          same runtime type is allocated for this purpose.</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an array containing the elements of the list</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ArrayStoreException if the runtime type of the specified array</span><span class="hljs-comment">     *         is not a supertype of the runtime type of every element in</span><span class="hljs-comment">     *         this list</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if the specified array is null</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;        <span class="hljs-keyword">if</span> (a.length &lt; size)            a = (T[])java.lang.reflect.Array.newInstance(                                a.getClass().getComponentType(), size);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        Object[] result = a;        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next)            result[i++] = x.item;        <span class="hljs-keyword">if</span> (a.length &gt; size)            a[size] = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">876323262645176354L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Saves the state of this &#123;<span class="hljs-doctag">@code</span> LinkedList&#125; instance to a stream</span><span class="hljs-comment">     * (that is, serializes it).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@serialData</span> The size of the list (the number of elements it</span><span class="hljs-comment">     *             contains) is emitted (int), followed by all of its</span><span class="hljs-comment">     *             elements (each an Object) in the proper order.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException </span>&#123;        <span class="hljs-comment">// Write out any hidden serialization magic</span>        s.defaultWriteObject();        <span class="hljs-comment">// Write out size</span>        s.writeInt(size);        <span class="hljs-comment">// Write out all elements in the proper order.</span>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next)            s.writeObject(x.item);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Reconstitutes this &#123;<span class="hljs-doctag">@code</span> LinkedList&#125; instance from a stream</span><span class="hljs-comment">     * (that is, deserializes it).</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;        <span class="hljs-comment">// Read in any hidden serialization magic</span>        s.defaultReadObject();        <span class="hljs-comment">// Read in size</span>        <span class="hljs-keyword">int</span> size = s.readInt();        <span class="hljs-comment">// Read in all elements in the proper order.</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)            linkLast((E)s.readObject());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates a &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt;</span><span class="hljs-comment">     * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;<span class="hljs-doctag">@link</span> Spliterator&#125; over the elements in this</span><span class="hljs-comment">     * list.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;The &#123;<span class="hljs-doctag">@code</span> Spliterator&#125; reports &#123;<span class="hljs-doctag">@link</span> Spliterator#SIZED&#125; and</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Spliterator#ORDERED&#125;.  Overriding implementations should document</span><span class="hljs-comment">     * the reporting of additional characteristic values.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@implNote</span></span><span class="hljs-comment">     * The &#123;<span class="hljs-doctag">@code</span> Spliterator&#125; additionally reports &#123;<span class="hljs-doctag">@link</span> Spliterator#SUBSIZED&#125;</span><span class="hljs-comment">     * and implements &#123;<span class="hljs-doctag">@code</span> trySplit&#125; to permit limited parallelism..</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a &#123;<span class="hljs-doctag">@code</span> Spliterator&#125; over the elements in this list</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spliterator&lt;E&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LLSpliterator&lt;E&gt;(<span class="hljs-keyword">this</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">/** A customized variant of Spliterators.IteratorSpliterator */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LLSpliterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Spliterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BATCH_UNIT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>;  <span class="hljs-comment">// batch array size increment</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_BATCH = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">25</span>;  <span class="hljs-comment">// max batch array size;</span>        <span class="hljs-keyword">final</span> LinkedList&lt;E&gt; list; <span class="hljs-comment">// null OK unless traversed</span>        Node&lt;E&gt; current;      <span class="hljs-comment">// current node; null until initialized</span>        <span class="hljs-keyword">int</span> est;              <span class="hljs-comment">// size estimate; -1 until first needed</span>        <span class="hljs-keyword">int</span> expectedModCount; <span class="hljs-comment">// initialized when est set</span>        <span class="hljs-keyword">int</span> batch;            <span class="hljs-comment">// batch size for splits</span>        LLSpliterator(LinkedList&lt;E&gt; list, <span class="hljs-keyword">int</span> est, <span class="hljs-keyword">int</span> expectedModCount) &#123;            <span class="hljs-keyword">this</span>.list = list;            <span class="hljs-keyword">this</span>.est = est;            <span class="hljs-keyword">this</span>.expectedModCount = expectedModCount;        &#125;        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEst</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">int</span> s; <span class="hljs-comment">// force initialization</span>            <span class="hljs-keyword">final</span> LinkedList&lt;E&gt; lst;            <span class="hljs-keyword">if</span> ((s = est) &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> ((lst = list) == <span class="hljs-keyword">null</span>)                    s = est = <span class="hljs-number">0</span>;                <span class="hljs-keyword">else</span> &#123;                    expectedModCount = lst.modCount;                    current = lst.first;                    s = est = lst.size;                &#125;            &#125;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">estimateSize</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>) getEst(); &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Spliterator&lt;E&gt; <span class="hljs-title">trySplit</span><span class="hljs-params">()</span> </span>&#123;            Node&lt;E&gt; p;            <span class="hljs-keyword">int</span> s = getEst();            <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">1</span> &amp;&amp; (p = current) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">int</span> n = batch + BATCH_UNIT;                <span class="hljs-keyword">if</span> (n &gt; s)                    n = s;                <span class="hljs-keyword">if</span> (n &gt; MAX_BATCH)                    n = MAX_BATCH;                Object[] a = <span class="hljs-keyword">new</span> Object[n];                <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;                <span class="hljs-keyword">do</span> &#123; a[j++] = p.item; &#125; <span class="hljs-keyword">while</span> ((p = p.next) != <span class="hljs-keyword">null</span> &amp;&amp; j &lt; n);                current = p;                batch = j;                est = s - j;                <span class="hljs-keyword">return</span> Spliterators.spliterator(a, <span class="hljs-number">0</span>, j, Spliterator.ORDERED);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;            Node&lt;E&gt; p; <span class="hljs-keyword">int</span> n;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">if</span> ((n = getEst()) &gt; <span class="hljs-number">0</span> &amp;&amp; (p = current) != <span class="hljs-keyword">null</span>) &#123;                current = <span class="hljs-keyword">null</span>;                est = <span class="hljs-number">0</span>;                <span class="hljs-keyword">do</span> &#123;                    E e = p.item;                    p = p.next;                    action.accept(e);                &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; --n &gt; <span class="hljs-number">0</span>);            &#125;            <span class="hljs-keyword">if</span> (list.modCount != expectedModCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;            Node&lt;E&gt; p;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">if</span> (getEst() &gt; <span class="hljs-number">0</span> &amp;&amp; (p = current) != <span class="hljs-keyword">null</span>) &#123;                --est;                E e = p.item;                current = p.next;                action.accept(e);                <span class="hljs-keyword">if</span> (list.modCount != expectedModCount)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LinkedList类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList探究</title>
    <link href="/2020/11/12/arrayList/"/>
    <url>/2020/11/12/arrayList/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList探究"><a href="#ArrayList探究" class="headerlink" title="ArrayList探究"></a>ArrayList探究</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>实现List接口,继承自AbstractList</li><li>基于数组实现，内存连续</li><li>便利查找效率高（数组），但插入删除效率低（数组）</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li>查找优先，或者不经常修改时候推荐使用</li><li>默认容量大小为10，1.5倍扩容</li><li>Arrays.copyOf 和 System.arrayCopy</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189L</span>;    <span class="hljs-comment">//数组初始化大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;        <span class="hljs-comment">//空对象数组</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;    <span class="hljs-comment">//对象数组</span>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span>    <span class="hljs-comment">//已使用大小，容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-comment">//根据参数，初始化ArrayList</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+                                               initialCapacity);        &#125;    &#125;        <span class="hljs-comment">//无参初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//默认空数组赋值给对象数组</span>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    &#125;    <span class="hljs-comment">//通过给定集合初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;        elementData = c.toArray();        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>            <span class="hljs-comment">//防止转换失败，重新进行拷贝</span>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                <span class="hljs-title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// replace with empty array.</span>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;        &#125;    &#125;    <span class="hljs-comment">//去除未使用的空部分，即重新拷贝数组</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;        modCount++;        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;            elementData = (size == <span class="hljs-number">0</span>)              ? EMPTY_ELEMENTDATA              : Arrays.copyOf(elementData, size);        &#125;    &#125;    <span class="hljs-comment">//确保容量足够，不够进行扩容</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)            <span class="hljs-comment">// any size if not default element table</span>            ? <span class="hljs-number">0</span>            <span class="hljs-comment">// larger than default for default empty table. It's already</span>            <span class="hljs-comment">// supposed to be at default size.</span>            : DEFAULT_CAPACITY;        <span class="hljs-comment">//给定最小容量&gt;最小扩张</span>        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;            ensureExplicitCapacity(minCapacity);        &#125;    &#125;        <span class="hljs-comment">//计算容量</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;            <span class="hljs-comment">//空集合时候，取给定值和默认大小中较大的一个</span>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);        &#125;        <span class="hljs-comment">//直接返回给定的最小容量</span>        <span class="hljs-keyword">return</span> minCapacity;    &#125;        <span class="hljs-comment">//内部方法，确保容量足够</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        modCount++;        <span class="hljs-comment">// overflow-conscious code</span>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)            grow(minCapacity);    &#125;    <span class="hljs-comment">//默认数组最大值 </span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;    <span class="hljs-comment">//对数组进行扩容</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-comment">// overflow-conscious code</span>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;        <span class="hljs-comment">//扩容为之前大小1.5倍</span>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-comment">//取扩容后的大小和给定值中较大的一个</span>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)            newCapacity = minCapacity;        <span class="hljs-comment">//超过最大值时候进行处理</span>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)            newCapacity = hugeCapacity(minCapacity);        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>        <span class="hljs-comment">//数组扩容拷贝</span>        elementData = Arrays.copyOf(elementData, newCapacity);    &#125;    <span class="hljs-comment">//极值处理</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();        <span class="hljs-comment">//最大值仍为Integer.MaxValue</span>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;    &#125;    <span class="hljs-comment">//获取其中元素（已经使用）的个数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size;    &#125;    <span class="hljs-comment">//判断是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;    &#125;        <span class="hljs-comment">//判断是否包含給顶参数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//若为空，则找到空对象的下标</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//不为空，则返回相等的对象下标</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))                    <span class="hljs-keyword">return</span> i;        &#125;        <span class="hljs-comment">//不存在则返回-1</span>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;        <span class="hljs-comment">//获取对象最后一次出现的下标</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-comment">//倒叙查找</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))                    <span class="hljs-keyword">return</span> i;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//对象的克隆，浅克隆</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();            v.elementData = Arrays.copyOf(elementData, size);            <span class="hljs-comment">//修改次数置为0</span>            v.modCount = <span class="hljs-number">0</span>;            <span class="hljs-keyword">return</span> v;        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            <span class="hljs-comment">// this shouldn't happen, since we are Cloneable</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);        &#125;    &#125;    <span class="hljs-comment">//返回对象数组</span>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);    &#125;    <span class="hljs-comment">//转换为数组</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;        <span class="hljs-keyword">if</span> (a.length &lt; size)            <span class="hljs-comment">//长度小，Arrays.copyOf    </span>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());        <span class="hljs-comment">//长度大System.arrayCopy    </span>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);        <span class="hljs-keyword">if</span> (a.length &gt; size)            a[size] = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-comment">// 获取给定下标的值（内部方法）</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> (E) elementData[index];    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//边界校验</span>        rangeCheck(index);        <span class="hljs-keyword">return</span> elementData(index);    &#125;    <span class="hljs-comment">//设置给定下标的值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;        rangeCheck(index);        E oldValue = elementData(index);        elementData[index] = element;        <span class="hljs-comment">//返回旧值</span>        <span class="hljs-keyword">return</span> oldValue;    &#125;    <span class="hljs-comment">//添加元素（尾部添加）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;         <span class="hljs-comment">// 确保空间足够，不够则进行扩容</span>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>        elementData[size++] = e;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;        <span class="hljs-comment">//指定位置插入元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;        <span class="hljs-comment">//边界值校验</span>        rangeCheckForAdd(index);        <span class="hljs-comment">//确保空间足够，不够则进行扩容</span>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>        <span class="hljs-comment">//数组拷贝，从index下标开始  拷贝到从index+1下标开始</span>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,                         size - index);        <span class="hljs-comment">//index位置赋值</span>        elementData[index] = element;        <span class="hljs-comment">//已使用长度增加</span>        size++;    &#125;    <span class="hljs-comment">//删除指定位置的元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//位置校验</span>        rangeCheck(index);        <span class="hljs-comment">//修改次数自增</span>        modCount++;        E oldValue = elementData(index);        <span class="hljs-comment">//计算需要移动的值的数量（删除值后续往前移动）</span>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            <span class="hljs-comment">//数组拷贝,index+1开始的下标拷贝给index开始的下标</span>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                             numMoved);        <span class="hljs-comment">//尾部元素置空    </span>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>        <span class="hljs-comment">//返回已删除的旧值</span>        <span class="hljs-keyword">return</span> oldValue;    &#125;    <span class="hljs-comment">//删除ArrayList中指定元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//为空时删除空元素</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;                    fastRemove(index);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//不为空时,equals比较删除相同值元素</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;                    fastRemove(index);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;        &#125;        <span class="hljs-comment">//未找到则删除失败，返回false</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//快速删除方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//修改次数自增</span>        modCount++;        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            <span class="hljs-comment">//数组拷贝，index+1位置开始元素拷贝给index位置开始元素</span>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                             numMoved);        <span class="hljs-comment">//尾部置空，如果是存放对象，此处不在引用，可以让gc有机会回收</span>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>    &#125;    <span class="hljs-comment">//清空当前ArrayList</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//修改次数自增</span>        modCount++;        <span class="hljs-comment">// clear to let GC do its work</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)            <span class="hljs-comment">//存值部分逐一置为null</span>            elementData[i] = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//使用个数置为0    </span>        size = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//添加整个集合，本质是数组的拷贝</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;        Object[] a = c.toArray();        <span class="hljs-keyword">int</span> numNew = a.length;        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);        size += numNew;        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;    &#125;        <span class="hljs-comment">//从指定位置开始，添加整个集合  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;        rangeCheckForAdd(index);        <span class="hljs-comment">//转换为对象数组</span>        Object[] a = c.toArray();        <span class="hljs-keyword">int</span> numNew = a.length;        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>        <span class="hljs-keyword">int</span> numMoved = size - index;        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            <span class="hljs-comment">//进行对象数组拷贝    </span>            System.arraycopy(elementData, index, elementData, index + numNew,                             numMoved);        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);        size += numNew;        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//删除指定区间内的数据</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex)</span> </span>&#123;        modCount++;        <span class="hljs-comment">//计算出需要拷贝的长度</span>        <span class="hljs-keyword">int</span> numMoved = size - toIndex;        <span class="hljs-comment">//进行数组拷贝</span>        System.arraycopy(elementData, toIndex, elementData, fromIndex,                         numMoved);        <span class="hljs-comment">// clear to let GC do its work</span>        <span class="hljs-comment">//计算出新的已使用长度</span>        <span class="hljs-keyword">int</span> newSize = size - (toIndex-fromIndex);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = newSize; i &lt; size; i++) &#123;            <span class="hljs-comment">//对于已经删除的元素，进行置空处理</span>            elementData[i] = <span class="hljs-keyword">null</span>;        &#125;        size = newSize;    &#125;    <span class="hljs-comment">//边界值校验</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheck</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &gt;= size)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));    &#125;    <span class="hljs-comment">//新增前边界值校验</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));    &#125;    <span class="hljs-comment">//返回越界信息</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Index: "</span>+index+<span class="hljs-string">", Size: "</span>+size;    &#125;    <span class="hljs-comment">//批量移除</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;        <span class="hljs-comment">//判断是否为空</span>        Objects.requireNonNull(c);        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">//取交集方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;        Objects.requireNonNull(c);        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-keyword">true</span>);    &#125;        <span class="hljs-comment">//批量移除方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">batchRemove</span><span class="hljs-params">(Collection&lt;?&gt; c, <span class="hljs-keyword">boolean</span> complement)</span> </span>&#123;        <span class="hljs-keyword">final</span> Object[] elementData = <span class="hljs-keyword">this</span>.elementData;        <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span> modified = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (; r &lt; size; r++)                <span class="hljs-keyword">if</span> (c.contains(elementData[r]) == complement)                    <span class="hljs-comment">//根据传值，去交集是两者都存在，直接存入数组（取交集）；其他情况不存在才保存（删除）</span>                    elementData[w++] = elementData[r];        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// Preserve behavioral compatibility with AbstractCollection,</span>            <span class="hljs-comment">// even if c.contains() throws.</span>            <span class="hljs-keyword">if</span> (r != size) &#123;                <span class="hljs-comment">//从r开始进行进行数组拷贝</span>                System.arraycopy(elementData, r,                                 elementData, w,                                 size - r);                <span class="hljs-comment">//重新计算长度</span>                w += size - r;            &#125;            <span class="hljs-keyword">if</span> (w != size) &#123;                <span class="hljs-comment">// clear to let GC do its work</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &lt; size; i++)                     <span class="hljs-comment">//后续置空</span>                    elementData[i] = <span class="hljs-keyword">null</span>;                modCount += size - w;                size = w;                modified = <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> modified;    &#125;       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;        <span class="hljs-comment">// Write out element count, and any hidden stuff</span>        <span class="hljs-keyword">int</span> expectedModCount = modCount;        s.defaultWriteObject();        <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span>        s.writeInt(size);        <span class="hljs-comment">// Write out all elements in the proper order.</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;            s.writeObject(elementData[i]);        &#125;        <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;        elementData = EMPTY_ELEMENTDATA;        <span class="hljs-comment">// Read in size, and any hidden stuff</span>        s.defaultReadObject();        <span class="hljs-comment">// Read in capacity</span>        s.readInt(); <span class="hljs-comment">// ignored</span>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// be like clone(), allocate array based upon size not capacity</span>            <span class="hljs-keyword">int</span> capacity = calculateCapacity(elementData, size);            SharedSecrets.getJavaOISAccess().checkArray(s, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">capacity</span>)</span>;            ensureCapacityInternal(size);            Object[] a = elementData;            <span class="hljs-comment">// Read in all elements in the proper order.</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;                a[i] = s.readObject();            &#125;        &#125;    &#125;    <span class="hljs-comment">//返回迭代器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Index: "</span>+index);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListItr(index);    &#125;    <span class="hljs-comment">//默认返回从零开始的迭代器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListItr(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();    &#125;    <span class="hljs-comment">//内部类 实现迭代器接口</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-comment">//指向的下个位置</span>        <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span>        <span class="hljs-comment">//末位</span>        <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span>        <span class="hljs-comment">//修改次数</span>        <span class="hljs-keyword">int</span> expectedModCount = modCount;        Itr() &#123;&#125;                <span class="hljs-comment">//是否还有下个节点</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> cursor != size;        &#125;                <span class="hljs-comment">//返回指向的下个节点</span>        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">//校验修改次数（b笨笨好）</span>            checkForComodification();            <span class="hljs-keyword">int</span> i = cursor;            <span class="hljs-keyword">if</span> (i &gt;= size)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();            Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            <span class="hljs-comment">//当前指向下一个节点</span>            cursor = i + <span class="hljs-number">1</span>;            <span class="hljs-comment">//返回当前节点尾部</span>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];        &#125;                <span class="hljs-comment">//删除节点</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();            <span class="hljs-comment">//比较修改次数</span>            checkForComodification();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//删除当前节点</span>                ArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);                <span class="hljs-comment">//当前指向已删除节点</span>                cursor = lastRet;                <span class="hljs-comment">//尾部为-1</span>                lastRet = -<span class="hljs-number">1</span>;                expectedModCount = modCount;            &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;                <span class="hljs-comment">//通过迭代器形式的遍历        </span>        <span class="hljs-meta">@Override</span>        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; consumer)</span> </span>&#123;            <span class="hljs-comment">//边界以及空值遍历</span>            Objects.requireNonNull(consumer);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = ArrayList.<span class="hljs-keyword">this</span>.size;            <span class="hljs-keyword">int</span> i = cursor;            <span class="hljs-keyword">if</span> (i &gt;= size) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//获取当前数组不可变</span>            <span class="hljs-keyword">final</span> Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;            <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;            <span class="hljs-keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;                consumer.accept((E) elementData[i++]);            &#125;            <span class="hljs-comment">// update once at end of iteration to reduce heap write traffic</span>            cursor = i;            lastRet = i - <span class="hljs-number">1</span>;            checkForComodification();        &#125;        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (modCount != expectedModCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * An optimized version of AbstractList.ListItr</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListItr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        ListItr(<span class="hljs-keyword">int</span> index) &#123;            <span class="hljs-keyword">super</span>();            cursor = index;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> cursor != <span class="hljs-number">0</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> cursor;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> cursor - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">previous</span><span class="hljs-params">()</span> </span>&#123;            checkForComodification();            <span class="hljs-keyword">int</span> i = cursor - <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();            Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            cursor = i;            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span> </span>&#123;            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();            checkForComodification();            <span class="hljs-keyword">try</span> &#123;                ArrayList.<span class="hljs-keyword">this</span>.set(lastRet, e);            &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;            checkForComodification();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">int</span> i = cursor;                ArrayList.<span class="hljs-keyword">this</span>.add(i, e);                cursor = i + <span class="hljs-number">1</span>;                lastRet = -<span class="hljs-number">1</span>;                expectedModCount = modCount;            &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a view of the portion of this list between the specified</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="hljs-doctag">@code</span> toIndex&#125;, exclusive.  (If</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> fromIndex&#125; and &#123;<span class="hljs-doctag">@code</span> toIndex&#125; are equal, the returned list is</span><span class="hljs-comment">     * empty.)  The returned list is backed by this list, so non-structural</span><span class="hljs-comment">     * changes in the returned list are reflected in this list, and vice-versa.</span><span class="hljs-comment">     * The returned list supports all of the optional list operations.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;This method eliminates the need for explicit range operations (of</span><span class="hljs-comment">     * the sort that commonly exist for arrays).  Any operation that expects</span><span class="hljs-comment">     * a list can be used as a range operation by passing a subList view</span><span class="hljs-comment">     * instead of a whole list.  For example, the following idiom</span><span class="hljs-comment">     * removes a range of elements from a list:</span><span class="hljs-comment">     * &lt;pre&gt;</span><span class="hljs-comment">     *      list.subList(from, to).clear();</span><span class="hljs-comment">     * &lt;/pre&gt;</span><span class="hljs-comment">     * Similar idioms may be constructed for &#123;<span class="hljs-doctag">@link</span> #indexOf(Object)&#125; and</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> #lastIndexOf(Object)&#125;, and all of the algorithms in the</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Collections&#125; class can be applied to a subList.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;The semantics of the list returned by this method become undefined if</span><span class="hljs-comment">     * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in</span><span class="hljs-comment">     * any way other than via the returned list.  (Structural modifications are</span><span class="hljs-comment">     * those that change the size of this list, or otherwise perturb it in such</span><span class="hljs-comment">     * a fashion that iterations in progress may yield incorrect results.)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;E&gt; <span class="hljs-title">subList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex)</span> </span>&#123;        subListRangeCheck(fromIndex, toIndex, size);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SubList(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, fromIndex, toIndex);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subListRangeCheck</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex, <span class="hljs-keyword">int</span> size)</span> </span>&#123;        <span class="hljs-keyword">if</span> (fromIndex &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"fromIndex = "</span> + fromIndex);        <span class="hljs-keyword">if</span> (toIndex &gt; size)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"toIndex = "</span> + toIndex);        <span class="hljs-keyword">if</span> (fromIndex &gt; toIndex)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"fromIndex("</span> + fromIndex +                                               <span class="hljs-string">") &gt; toIndex("</span> + toIndex + <span class="hljs-string">")"</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractList&lt;E&gt; parent;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> parentOffset;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset;        <span class="hljs-keyword">int</span> size;        SubList(AbstractList&lt;E&gt; parent,                <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex) &#123;            <span class="hljs-keyword">this</span>.parent = parent;            <span class="hljs-keyword">this</span>.parentOffset = fromIndex;            <span class="hljs-keyword">this</span>.offset = offset + fromIndex;            <span class="hljs-keyword">this</span>.size = toIndex - fromIndex;            <span class="hljs-keyword">this</span>.modCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E e)</span> </span>&#123;            rangeCheck(index);            checkForComodification();            E oldValue = ArrayList.<span class="hljs-keyword">this</span>.elementData(offset + index);            ArrayList.<span class="hljs-keyword">this</span>.elementData[offset + index] = e;            <span class="hljs-keyword">return</span> oldValue;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;            rangeCheck(index);            checkForComodification();            <span class="hljs-keyword">return</span> ArrayList.<span class="hljs-keyword">this</span>.elementData(offset + index);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;            checkForComodification();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E e)</span> </span>&#123;            rangeCheckForAdd(index);            checkForComodification();            parent.add(parentOffset + index, e);            <span class="hljs-keyword">this</span>.modCount = parent.modCount;            <span class="hljs-keyword">this</span>.size++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;            rangeCheck(index);            checkForComodification();            E result = parent.remove(parentOffset + index);            <span class="hljs-keyword">this</span>.modCount = parent.modCount;            <span class="hljs-keyword">this</span>.size--;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex)</span> </span>&#123;            checkForComodification();            parent.removeRange(parentOffset + fromIndex,                               parentOffset + toIndex);            <span class="hljs-keyword">this</span>.modCount = parent.modCount;            <span class="hljs-keyword">this</span>.size -= toIndex - fromIndex;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;            <span class="hljs-keyword">return</span> addAll(<span class="hljs-keyword">this</span>.size, c);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;            rangeCheckForAdd(index);            <span class="hljs-keyword">int</span> cSize = c.size();            <span class="hljs-keyword">if</span> (cSize==<span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            checkForComodification();            parent.addAll(parentOffset + index, c);            <span class="hljs-keyword">this</span>.modCount = parent.modCount;            <span class="hljs-keyword">this</span>.size += cSize;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> listIterator();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index)</span> </span>&#123;            checkForComodification();            rangeCheckForAdd(index);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-keyword">this</span>.offset;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListIterator&lt;E&gt;() &#123;                <span class="hljs-keyword">int</span> cursor = index;                <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>;                <span class="hljs-keyword">int</span> expectedModCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">return</span> cursor != SubList.<span class="hljs-keyword">this</span>.size;                &#125;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;                    checkForComodification();                    <span class="hljs-keyword">int</span> i = cursor;                    <span class="hljs-keyword">if</span> (i &gt;= SubList.<span class="hljs-keyword">this</span>.size)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();                    Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;                    <span class="hljs-keyword">if</span> (offset + i &gt;= elementData.length)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                    cursor = i + <span class="hljs-number">1</span>;                    <span class="hljs-keyword">return</span> (E) elementData[offset + (lastRet = i)];                &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">return</span> cursor != <span class="hljs-number">0</span>;                &#125;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">previous</span><span class="hljs-params">()</span> </span>&#123;                    checkForComodification();                    <span class="hljs-keyword">int</span> i = cursor - <span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();                    Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;                    <span class="hljs-keyword">if</span> (offset + i &gt;= elementData.length)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                    cursor = i;                    <span class="hljs-keyword">return</span> (E) elementData[offset + (lastRet = i)];                &#125;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; consumer)</span> </span>&#123;                    Objects.requireNonNull(consumer);                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = SubList.<span class="hljs-keyword">this</span>.size;                    <span class="hljs-keyword">int</span> i = cursor;                    <span class="hljs-keyword">if</span> (i &gt;= size) &#123;                        <span class="hljs-keyword">return</span>;                    &#125;                    <span class="hljs-keyword">final</span> Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;                    <span class="hljs-keyword">if</span> (offset + i &gt;= elementData.length) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                    &#125;                    <span class="hljs-keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;                        consumer.accept((E) elementData[offset + (i++)]);                    &#125;                    <span class="hljs-comment">// update once at end of iteration to reduce heap write traffic</span>                    lastRet = cursor = i;                    checkForComodification();                &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">return</span> cursor;                &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">return</span> cursor - <span class="hljs-number">1</span>;                &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();                    checkForComodification();                    <span class="hljs-keyword">try</span> &#123;                        SubList.<span class="hljs-keyword">this</span>.remove(lastRet);                        cursor = lastRet;                        lastRet = -<span class="hljs-number">1</span>;                        expectedModCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;                    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                    &#125;                &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span> </span>&#123;                    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();                    checkForComodification();                    <span class="hljs-keyword">try</span> &#123;                        ArrayList.<span class="hljs-keyword">this</span>.set(offset + lastRet, e);                    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                    &#125;                &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;                    checkForComodification();                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">int</span> i = cursor;                        SubList.<span class="hljs-keyword">this</span>.add(i, e);                        cursor = i + <span class="hljs-number">1</span>;                        lastRet = -<span class="hljs-number">1</span>;                        expectedModCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;                    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                    &#125;                &#125;                <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">if</span> (expectedModCount != ArrayList.<span class="hljs-keyword">this</span>.modCount)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                &#125;            &#125;;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;E&gt; <span class="hljs-title">subList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex)</span> </span>&#123;            subListRangeCheck(fromIndex, toIndex, size);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SubList(<span class="hljs-keyword">this</span>, offset, fromIndex, toIndex);        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheck</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;            <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;            <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-keyword">this</span>.size)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"Index: "</span>+index+<span class="hljs-string">", Size: "</span>+<span class="hljs-keyword">this</span>.size;        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (ArrayList.<span class="hljs-keyword">this</span>.modCount != <span class="hljs-keyword">this</span>.modCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Spliterator&lt;E&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;            checkForComodification();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayListSpliterator&lt;E&gt;(ArrayList.<span class="hljs-keyword">this</span>, offset,                                               offset + <span class="hljs-keyword">this</span>.size, <span class="hljs-keyword">this</span>.modCount);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;        Objects.requireNonNull(action);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        <span class="hljs-keyword">final</span> E[] elementData = (E[]) <span class="hljs-keyword">this</span>.elementData;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.size;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;            action.accept(elementData[i]);        &#125;        <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates a &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt;</span><span class="hljs-comment">     * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;<span class="hljs-doctag">@link</span> Spliterator&#125; over the elements in this</span><span class="hljs-comment">     * list.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;The &#123;<span class="hljs-doctag">@code</span> Spliterator&#125; reports &#123;<span class="hljs-doctag">@link</span> Spliterator#SIZED&#125;,</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Spliterator#SUBSIZED&#125;, and &#123;<span class="hljs-doctag">@link</span> Spliterator#ORDERED&#125;.</span><span class="hljs-comment">     * Overriding implementations should document the reporting of additional</span><span class="hljs-comment">     * characteristic values.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a &#123;<span class="hljs-doctag">@code</span> Spliterator&#125; over the elements in this list</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spliterator&lt;E&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayListSpliterator&lt;&gt;(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">/** Index-based split-by-two, lazily initialized Spliterator */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListSpliterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Spliterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * If ArrayLists were immutable, or structurally immutable (no</span><span class="hljs-comment">         * adds, removes, etc), we could implement their spliterators</span><span class="hljs-comment">         * with Arrays.spliterator. Instead we detect as much</span><span class="hljs-comment">         * interference during traversal as practical without</span><span class="hljs-comment">         * sacrificing much performance. We rely primarily on</span><span class="hljs-comment">         * modCounts. These are not guaranteed to detect concurrency</span><span class="hljs-comment">         * violations, and are sometimes overly conservative about</span><span class="hljs-comment">         * within-thread interference, but detect enough problems to</span><span class="hljs-comment">         * be worthwhile in practice. To carry this out, we (1) lazily</span><span class="hljs-comment">         * initialize fence and expectedModCount until the latest</span><span class="hljs-comment">         * point that we need to commit to the state we are checking</span><span class="hljs-comment">         * against; thus improving precision.  (This doesn't apply to</span><span class="hljs-comment">         * SubLists, that create spliterators with current non-lazy</span><span class="hljs-comment">         * values).  (2) We perform only a single</span><span class="hljs-comment">         * ConcurrentModificationException check at the end of forEach</span><span class="hljs-comment">         * (the most performance-sensitive method). When using forEach</span><span class="hljs-comment">         * (as opposed to iterators), we can normally only detect</span><span class="hljs-comment">         * interference after actions, not before. Further</span><span class="hljs-comment">         * CME-triggering checks apply to all other possible</span><span class="hljs-comment">         * violations of assumptions for example null or too-small</span><span class="hljs-comment">         * elementData array given its size(), that could only have</span><span class="hljs-comment">         * occurred due to interference.  This allows the inner loop</span><span class="hljs-comment">         * of forEach to run without any further checks, and</span><span class="hljs-comment">         * simplifies lambda-resolution. While this does entail a</span><span class="hljs-comment">         * number of checks, note that in the common case of</span><span class="hljs-comment">         * list.stream().forEach(a), no checks or other computation</span><span class="hljs-comment">         * occur anywhere other than inside forEach itself.  The other</span><span class="hljs-comment">         * less-often-used methods cannot take advantage of most of</span><span class="hljs-comment">         * these streamlinings.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;E&gt; list;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index; <span class="hljs-comment">// current index, modified on advance/split</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fence; <span class="hljs-comment">// -1 until used; then one past last index</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expectedModCount; <span class="hljs-comment">// initialized when fence set</span>        <span class="hljs-comment">/** Create new spliterator covering the given  range */</span>        ArrayListSpliterator(ArrayList&lt;E&gt; list, <span class="hljs-keyword">int</span> origin, <span class="hljs-keyword">int</span> fence,                             <span class="hljs-keyword">int</span> expectedModCount) &#123;            <span class="hljs-keyword">this</span>.list = list; <span class="hljs-comment">// OK if null unless traversed</span>            <span class="hljs-keyword">this</span>.index = origin;            <span class="hljs-keyword">this</span>.fence = fence;            <span class="hljs-keyword">this</span>.expectedModCount = expectedModCount;        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFence</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// initialize fence to size on first use</span>            <span class="hljs-keyword">int</span> hi; <span class="hljs-comment">// (a specialized variant appears in method forEach)</span>            ArrayList&lt;E&gt; lst;            <span class="hljs-keyword">if</span> ((hi = fence) &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> ((lst = list) == <span class="hljs-keyword">null</span>)                    hi = fence = <span class="hljs-number">0</span>;                <span class="hljs-keyword">else</span> &#123;                    expectedModCount = lst.modCount;                    hi = fence = lst.size;                &#125;            &#125;            <span class="hljs-keyword">return</span> hi;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayListSpliterator&lt;E&gt; <span class="hljs-title">trySplit</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> (lo &gt;= mid) ? <span class="hljs-keyword">null</span> : <span class="hljs-comment">// divide range in half unless too small</span>                <span class="hljs-keyword">new</span> ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,                                            expectedModCount);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">int</span> hi = getFence(), i = index;            <span class="hljs-keyword">if</span> (i &lt; hi) &#123;                index = i + <span class="hljs-number">1</span>;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E e = (E)list.elementData[i];                action.accept(e);                <span class="hljs-keyword">if</span> (list.modCount != expectedModCount)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;            <span class="hljs-keyword">int</span> i, hi, mc; <span class="hljs-comment">// hoist accesses and checks from loop</span>            ArrayList&lt;E&gt; lst; Object[] a;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">if</span> ((lst = list) != <span class="hljs-keyword">null</span> &amp;&amp; (a = lst.elementData) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> ((hi = fence) &lt; <span class="hljs-number">0</span>) &#123;                    mc = lst.modCount;                    hi = lst.size;                &#125;                <span class="hljs-keyword">else</span>                    mc = expectedModCount;                <span class="hljs-keyword">if</span> ((i = index) &gt;= <span class="hljs-number">0</span> &amp;&amp; (index = hi) &lt;= a.length) &#123;                    <span class="hljs-keyword">for</span> (; i &lt; hi; ++i) &#123;                        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E e = (E) a[i];                        action.accept(e);                    &#125;                    <span class="hljs-keyword">if</span> (lst.modCount == mc)                        <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">estimateSize</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>) (getFence() - index);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> E&gt; filter)</span> </span>&#123;        Objects.requireNonNull(filter);        <span class="hljs-comment">// figure out which elements are to be removed</span>        <span class="hljs-comment">// any exception thrown from the filter predicate at this stage</span>        <span class="hljs-comment">// will leave the collection unmodified</span>        <span class="hljs-keyword">int</span> removeCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">final</span> BitSet removeSet = <span class="hljs-keyword">new</span> BitSet(size);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.size;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)            <span class="hljs-keyword">final</span> E element = (E) elementData[i];            <span class="hljs-keyword">if</span> (filter.test(element)) &#123;                removeSet.set(i);                removeCount++;            &#125;        &#125;        <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;        <span class="hljs-comment">// shift surviving elements left over the spaces left by removed elements</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> anyToRemove = removeCount &gt; <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (anyToRemove) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> newSize = size - removeCount;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;                i = removeSet.nextClearBit(i);                elementData[j] = elementData[i];            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=newSize; k &lt; size; k++) &#123;                elementData[k] = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// Let gc do its work</span>            &#125;            <span class="hljs-keyword">this</span>.size = newSize;            <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;            modCount++;        &#125;        <span class="hljs-keyword">return</span> anyToRemove;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;        Objects.requireNonNull(operator);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.size;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;            elementData[i] = operator.apply((E) elementData[i]);        &#125;        <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;        modCount++;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;        Arrays.sort((E[]) elementData, <span class="hljs-number">0</span>, size, c);        <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;        modCount++;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArrayList类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StringBuilder类探究</title>
    <link href="/2020/11/09/stringBuilder/"/>
    <url>/2020/11/09/stringBuilder/</url>
    
    <content type="html"><![CDATA[<h1 id="StringBuilder类探究"><a href="#StringBuilder类探究" class="headerlink" title="StringBuilder类探究"></a>StringBuilder类探究</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>实现自AbstractStringBuilder</li><li>主要方法未synchronize修饰，线程不安全</li><li>单线程内适用</li><li>final类，不可继承</li><li>内容可变(内部字符数组未用final)</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li>性能 StringBuilder &gt; StringBuffer &gt; String (添加大量字符时)</li><li>单一线程优先使用</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li><p>AbstractStringBuilder</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">//字符数组    </span>    <span class="hljs-keyword">char</span>[] value;    <span class="hljs-comment">//已用长度</span>    <span class="hljs-keyword">int</span> count;        <span class="hljs-comment">//数据初始化方法   </span>    AbstractStringBuilder() &#123;    &#125;    AbstractStringBuilder(<span class="hljs-keyword">int</span> capacity) &#123;        value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[capacity];    &#125;        <span class="hljs-comment">//获取字符串长度（已经使用去存储字符串长度）</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-comment">//获取字符数组长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value.length;    &#125;    <span class="hljs-comment">//确保容量足够</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (minimumCapacity &gt; <span class="hljs-number">0</span>)            ensureCapacityInternal(minimumCapacity);    &#125;    <span class="hljs-comment">//内部扩容方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;        <span class="hljs-comment">// overflow-conscious code</span>        <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;            value = Arrays.copyOf(value,                    newCapacity(minimumCapacity));        &#125;    &#125;    <span class="hljs-comment">//数组长度最大值</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;    <span class="hljs-comment">//重新设置长度</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-comment">//2倍+2扩容</span>        <span class="hljs-keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;        <span class="hljs-comment">//此处取较大值（默认的2倍+2和给定的值）</span>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;            newCapacity = minCapacity;        &#125;        <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)            ? hugeCapacity(minCapacity)            : newCapacity;    &#125;        <span class="hljs-comment">//极值处理    </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();        &#125;        <span class="hljs-comment">//最大也不能超过Integer.MaxValue(最大值)</span>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)            ? minCapacity : MAX_ARRAY_SIZE;    &#125;    <span class="hljs-comment">//去除未使用空间,实际是对已用数组的拷贝</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (count &lt; value.length) &#123;            value = Arrays.copyOf(value, count);        &#125;    &#125;    <span class="hljs-comment">//重新设置长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newLength)</span> </span>&#123;        <span class="hljs-keyword">if</span> (newLength &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(newLength);        <span class="hljs-comment">//确保空间足够</span>        ensureCapacityInternal(newLength);        <span class="hljs-keyword">if</span> (count &lt; newLength) &#123;            <span class="hljs-comment">//不足部分'\0'填充    </span>            Arrays.fill(value, count, newLength, <span class="hljs-string">'\0'</span>);        &#125;                count = newLength;    &#125;    <span class="hljs-comment">//获取给定下标的字符</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        <span class="hljs-keyword">return</span> value[index];    &#125;    <span class="hljs-comment">//获取给定下标的码值（一般为ASCII码）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        &#125;        <span class="hljs-keyword">return</span> Character.codePointAtImpl(value, index, count);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointBefore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> ((i &lt; <span class="hljs-number">0</span>) || (i &gt;= count)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        &#125;        <span class="hljs-keyword">return</span> Character.codePointBeforeImpl(value, index, <span class="hljs-number">0</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span> || endIndex &gt; count || beginIndex &gt; endIndex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();        &#125;        <span class="hljs-keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex-beginIndex);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> codePointOffset)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();        &#125;        <span class="hljs-keyword">return</span> Character.offsetByCodePointsImpl(value, <span class="hljs-number">0</span>, count,                                                index, codePointOffset);    &#125;        <span class="hljs-comment">//数组拷贝，将原数组的起始位置坐标 存入指定数组的指定位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcBegin, <span class="hljs-keyword">int</span> srcEnd, <span class="hljs-keyword">char</span>[] dst, <span class="hljs-keyword">int</span> dstBegin)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> (srcBegin &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcBegin);        <span class="hljs-keyword">if</span> ((srcEnd &lt; <span class="hljs-number">0</span>) || (srcEnd &gt; count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcEnd);        <span class="hljs-keyword">if</span> (srcBegin &gt; srcEnd)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(<span class="hljs-string">"srcBegin &gt; srcEnd"</span>);        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);    &#125;        <span class="hljs-comment">//设置给定下标的字符</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span> ch)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        value[index] = ch;    &#125;    <span class="hljs-comment">//尾部添加字符串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> append(String.valueOf(obj));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">int</span> len = str.length();        <span class="hljs-comment">//确保长度足够，不够的进行扩容</span>        ensureCapacityInternal(count + len);        <span class="hljs-comment">//给定字符存入当前对象数组</span>        str.getChars(<span class="hljs-number">0</span>, len, value, count);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(StringBuffer sb)</span> </span>&#123;        <span class="hljs-keyword">if</span> (sb == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">int</span> len = sb.length();        ensureCapacityInternal(count + len);        sb.getChars(<span class="hljs-number">0</span>, len, value, count);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function">AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(AbstractStringBuilder asb)</span> </span>&#123;        <span class="hljs-keyword">if</span> (asb == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">int</span> len = asb.length();        ensureCapacityInternal(count + len);        asb.getChars(<span class="hljs-number">0</span>, len, value, count);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">if</span> (s <span class="hljs-keyword">instanceof</span> String)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append((String)s);        <span class="hljs-keyword">if</span> (s <span class="hljs-keyword">instanceof</span> AbstractStringBuilder)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append((AbstractStringBuilder)s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append(s, <span class="hljs-number">0</span>, s.length());    &#125;        <span class="hljs-comment">//添加空串</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> AbstractStringBuilder <span class="hljs-title">appendNull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> c = count;        ensureCapacityInternal(c + <span class="hljs-number">4</span>);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;        value[c++] = <span class="hljs-string">'n'</span>;        value[c++] = <span class="hljs-string">'u'</span>;        value[c++] = <span class="hljs-string">'l'</span>;        value[c++] = <span class="hljs-string">'l'</span>;        count = c;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            s = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">if</span> ((start &lt; <span class="hljs-number">0</span>) || (start &gt; end) || (end &gt; s.length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(                <span class="hljs-string">"start "</span> + start + <span class="hljs-string">", end "</span> + end + <span class="hljs-string">", s.length() "</span>                + s.length());        <span class="hljs-keyword">int</span> len = end - start;        ensureCapacityInternal(count + len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start, j = count; i &lt; end; i++, j++)            value[j] = s.charAt(i);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//添加字符串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = str.length;        ensureCapacityInternal(count + len);        <span class="hljs-comment">//此处使用System.arraycopy</span>        System.arraycopy(str, <span class="hljs-number">0</span>, value, count, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)                <span class="hljs-comment">// let arraycopy report AIOOBE for len &lt; 0</span>            ensureCapacityInternal(count + len);        System.arraycopy(str, offset, value, count, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//添加布尔值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span> (b) &#123;            ensureCapacityInternal(count + <span class="hljs-number">4</span>);            value[count++] = <span class="hljs-string">'t'</span>;            value[count++] = <span class="hljs-string">'r'</span>;            value[count++] = <span class="hljs-string">'u'</span>;            value[count++] = <span class="hljs-string">'e'</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            ensureCapacityInternal(count + <span class="hljs-number">5</span>);            value[count++] = <span class="hljs-string">'f'</span>;            value[count++] = <span class="hljs-string">'a'</span>;            value[count++] = <span class="hljs-string">'l'</span>;            value[count++] = <span class="hljs-string">'s'</span>;            value[count++] = <span class="hljs-string">'e'</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        ensureCapacityInternal(count + <span class="hljs-number">1</span>);        value[count++] = c;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//添加数字相关</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">if</span> (i == Integer.MIN_VALUE) &#123;            append(<span class="hljs-string">"-2147483648"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-keyword">int</span> appendedLength = (i &lt; <span class="hljs-number">0</span>) ? Integer.stringSize(-i) + <span class="hljs-number">1</span>                                     : Integer.stringSize(i);        <span class="hljs-keyword">int</span> spaceNeeded = count + appendedLength;        ensureCapacityInternal(spaceNeeded);        Integer.getChars(i, spaceNeeded, value);        count = spaceNeeded;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == Long.MIN_VALUE) &#123;            append(<span class="hljs-string">"-9223372036854775808"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-keyword">int</span> appendedLength = (l &lt; <span class="hljs-number">0</span>) ? Long.stringSize(-l) + <span class="hljs-number">1</span>                                     : Long.stringSize(l);        <span class="hljs-keyword">int</span> spaceNeeded = count + appendedLength;        ensureCapacityInternal(spaceNeeded);        Long.getChars(l, spaceNeeded, value);        count = spaceNeeded;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f)</span> </span>&#123;        FloatingDecimal.appendTo(f,<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;        FloatingDecimal.appendTo(d,<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//删除指定位置的串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);        <span class="hljs-keyword">if</span> (end &gt; count)            end = count;        <span class="hljs-keyword">if</span> (start &gt; end)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException();        <span class="hljs-keyword">int</span> len = end - start;        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;            System.arraycopy(value, start+len, value, start, count-end);            count -= len;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">appendCodePoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> codePoint)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = <span class="hljs-keyword">this</span>.count;        <span class="hljs-keyword">if</span> (Character.isBmpCodePoint(codePoint)) &#123;            ensureCapacityInternal(count + <span class="hljs-number">1</span>);            value[count] = (<span class="hljs-keyword">char</span>) codePoint;            <span class="hljs-keyword">this</span>.count = count + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isValidCodePoint(codePoint)) &#123;            ensureCapacityInternal(count + <span class="hljs-number">2</span>);            Character.toSurrogates(codePoint, value, count);            <span class="hljs-keyword">this</span>.count = count + <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//删除指定位置字符</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">deleteCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        System.arraycopy(value, index+<span class="hljs-number">1</span>, value, index, count-index-<span class="hljs-number">1</span>);        count--;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//字符串替换    </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, String str)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);        <span class="hljs-keyword">if</span> (start &gt; count)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(<span class="hljs-string">"start &gt; length()"</span>);        <span class="hljs-keyword">if</span> (start &gt; end)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(<span class="hljs-string">"start &gt; end"</span>);        <span class="hljs-keyword">if</span> (end &gt; count)            end = count;        <span class="hljs-keyword">int</span> len = str.length();        <span class="hljs-keyword">int</span> newCount = count + len - (end - start);        ensureCapacityInternal(newCount);        <span class="hljs-comment">//原来end字符串进行拷贝，空出位置</span>        System.arraycopy(value, end, value, start + len, count - end);        <span class="hljs-comment">//str存入</span>        str.getChars(value, start);        count = newCount;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-comment">//字符切割</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">return</span> substring(start, count);    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharSequence <span class="hljs-title">subSequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">return</span> substring(start, end);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);        <span class="hljs-keyword">if</span> (end &gt; count)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end);        <span class="hljs-keyword">if</span> (start &gt; end)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end - start);        <span class="hljs-comment">//直接返回新串</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, start, end - start);    &#125;    <span class="hljs-comment">//插入数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function">    </span>&#123;            <span class="hljs-comment">//边界值校验   </span>        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt; length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (len &lt; <span class="hljs-number">0</span>) || (offset &gt; str.length - len))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(                <span class="hljs-string">"offset "</span> + offset + <span class="hljs-string">", len "</span> + len + <span class="hljs-string">", str.length "</span>                + str.length);        <span class="hljs-comment">//扩容处理</span>        ensureCapacityInternal(count + len);        <span class="hljs-comment">//原位置数据往后偏移</span>        System.arraycopy(value, index, value, index + len, count - index);        <span class="hljs-comment">//str字符串插入</span>        System.arraycopy(str, offset, value, index, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, Object obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(obj));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, String str)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (offset &gt; length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)            str = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">int</span> len = str.length();        ensureCapacityInternal(count + len);        System.arraycopy(value, offset, value, offset + len, count - offset);        str.getChars(value, offset);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (offset &gt; length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        <span class="hljs-keyword">int</span> len = str.length;        ensureCapacityInternal(count + len);        System.arraycopy(value, offset, value, offset + len, count - offset);        System.arraycopy(str, <span class="hljs-number">0</span>, value, offset, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            s = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">if</span> (s <span class="hljs-keyword">instanceof</span> String)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.insert(dstOffset, (String)s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.insert(dstOffset, s, <span class="hljs-number">0</span>, s.length());    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s,</span></span><span class="hljs-function"><span class="hljs-params">                                         <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            s = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">if</span> ((dstOffset &lt; <span class="hljs-number">0</span>) || (dstOffset &gt; <span class="hljs-keyword">this</span>.length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"dstOffset "</span>+dstOffset);        <span class="hljs-keyword">if</span> ((start &lt; <span class="hljs-number">0</span>) || (end &lt; <span class="hljs-number">0</span>) || (start &gt; end) || (end &gt; s.length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(                <span class="hljs-string">"start "</span> + start + <span class="hljs-string">", end "</span> + end + <span class="hljs-string">", s.length() "</span>                + s.length());        <span class="hljs-keyword">int</span> len = end - start;        ensureCapacityInternal(count + len);        System.arraycopy(value, dstOffset, value, dstOffset + len,                         count - dstOffset);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)            value[dstOffset++] = s.charAt(i);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(b));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span> c)</span> </span>&#123;        ensureCapacityInternal(count + <span class="hljs-number">1</span>);        System.arraycopy(value, offset, value, offset + <span class="hljs-number">1</span>, count - offset);        value[offset] = c;        count += <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(i));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">long</span> l)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(l));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">float</span> f)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(f));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">double</span> d)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(d));    &#125;    <span class="hljs-comment">//获取Str首次出现的下标</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(str, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> String.indexOf(value, <span class="hljs-number">0</span>, count, str, fromIndex);    &#125;        <span class="hljs-comment">//最后一次出现的下标</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> lastIndexOf(str, count);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> String.lastIndexOf(value, <span class="hljs-number">0</span>, count, str, fromIndex);    &#125;    <span class="hljs-comment">//字符串翻转</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">boolean</span> hasSurrogates = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> n = count - <span class="hljs-number">1</span>;        <span class="hljs-comment">//从中间开始依次翻转</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = (n-<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;            <span class="hljs-keyword">int</span> k = n - j;            <span class="hljs-keyword">char</span> cj = value[j];            <span class="hljs-keyword">char</span> ck = value[k];            value[j] = ck;            value[k] = cj;            <span class="hljs-keyword">if</span> (Character.isSurrogate(cj) ||                Character.isSurrogate(ck)) &#123;                hasSurrogates = <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (hasSurrogates) &#123;            reverseAllValidSurrogatePairs();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/** Outlined helper method for reverse() */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseAllValidSurrogatePairs</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">char</span> c2 = value[i];            <span class="hljs-keyword">if</span> (Character.isLowSurrogate(c2)) &#123;                <span class="hljs-keyword">char</span> c1 = value[i + <span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (Character.isHighSurrogate(c1)) &#123;                    value[i++] = c1;                    value[i] = c2;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Needed by &#123;<span class="hljs-doctag">@code</span> String&#125; for the contentEquals method.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] getValue() &#123;        <span class="hljs-keyword">return</span> value;    &#125;&#125;</code></pre></li><li><p>StringBuilder类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilder</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStringBuilder</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">CharSequence</span></span><span class="hljs-class"></span>&#123;       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">4383685877147921099L</span>;    <span class="hljs-comment">//初始字符数组大小为16    </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        <span class="hljs-keyword">super</span>(capacity);    &#125;    <span class="hljs-comment">//根据字符串初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-comment">//长度为 16+字符串长度</span>        <span class="hljs-keyword">super</span>(str.length() + <span class="hljs-number">16</span>);        append(str);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(CharSequence seq)</span> </span>&#123;        <span class="hljs-keyword">this</span>(seq.length() + <span class="hljs-number">16</span>);        append(seq);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> append(String.valueOf(obj));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(StringBuffer sb)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(sb);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>     IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(s, start, end);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(str, offset, len);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(b);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(c);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(i);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lng)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(lng);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(f);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(d);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">appendCodePoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> codePoint)</span> </span>&#123;        <span class="hljs-keyword">super</span>.appendCodePoint(codePoint);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">super</span>.delete(start, end);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">deleteCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">super</span>.deleteCharAt(index);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, String str)</span> </span>&#123;        <span class="hljs-keyword">super</span>.replace(start, end, str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset,</span></span><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">super</span>.insert(index, str, offset, len);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, Object obj)</span> </span>&#123;            <span class="hljs-keyword">super</span>.insert(offset, obj);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, String str)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s)</span> </span>&#123;            <span class="hljs-keyword">super</span>.insert(dstOffset, s);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s,</span></span><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">super</span>.insert(dstOffset, s, start, end);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, b);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span> c)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, c);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, i);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">long</span> l)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, l);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">float</span> f)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, f);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">double</span> d)</span> </span>&#123;        <span class="hljs-keyword">super</span>.insert(offset, d);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.indexOf(str);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.indexOf(str, fromIndex);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.lastIndexOf(str);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.lastIndexOf(str, fromIndex);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.reverse();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Create a copy, don't share the array</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, <span class="hljs-number">0</span>, count);    &#125;    <span class="hljs-comment">//流处理相关</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException </span>&#123;        s.defaultWriteObject();        s.writeInt(count);        s.writeObject(value);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * readObject is called to restore the state of the StringBuffer from</span><span class="hljs-comment">     * a stream.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;        s.defaultReadObject();        count = s.readInt();        value = (<span class="hljs-keyword">char</span>[]) s.readObject();    &#125;&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>StringBuilder类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StringBuffer类探究</title>
    <link href="/2020/11/07/stringBuffer/"/>
    <url>/2020/11/07/stringBuffer/</url>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer类探究"><a href="#StringBuffer类探究" class="headerlink" title="StringBuffer类探究"></a>StringBuffer类探究</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>实现自AbstractStringBuilder</li><li>主要方法synchronize修饰，线程安全</li><li>final类，不可继承</li><li>内容可变(内部字符数组未用final)</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li>AbstractStringBuilder<pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">//字符数组，存放内容</span>    <span class="hljs-keyword">char</span>[] value;    <span class="hljs-comment">//已存字符个数</span>    <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">//初始化方法</span>    AbstractStringBuilder() &#123;    &#125;    AbstractStringBuilder(<span class="hljs-keyword">int</span> capacity) &#123;        value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[capacity];    &#125;        <span class="hljs-comment">//返回已使用长度</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-comment">//数组实际长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value.length;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Ensures that the capacity is at least equal to the specified minimum.</span><span class="hljs-comment">     * If the current capacity is less than the argument, then a new internal</span><span class="hljs-comment">     * array is allocated with greater capacity. The new capacity is the</span><span class="hljs-comment">     * larger of:</span><span class="hljs-comment">     * &lt;ul&gt;</span><span class="hljs-comment">     * &lt;li&gt;The &#123;<span class="hljs-doctag">@code</span> minimumCapacity&#125; argument.</span><span class="hljs-comment">     * &lt;li&gt;Twice the old capacity, plus &#123;<span class="hljs-doctag">@code</span> 2&#125;.</span><span class="hljs-comment">     * &lt;/ul&gt;</span><span class="hljs-comment">     * If the &#123;<span class="hljs-doctag">@code</span> minimumCapacity&#125; argument is nonpositive, this</span><span class="hljs-comment">     * method takes no action and simply returns.</span><span class="hljs-comment">     * Note that subsequent operations on this object can reduce the</span><span class="hljs-comment">     * actual capacity below that requested here.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   minimumCapacity   the minimum desired capacity.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (minimumCapacity &gt; <span class="hljs-number">0</span>)            ensureCapacityInternal(minimumCapacity);    &#125;    <span class="hljs-comment">//内部字符数组扩容</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;        <span class="hljs-comment">//给定数组大于当前数组最大长度时，进行扩容 </span>        <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;            value = Arrays.copyOf(value,                    newCapacity(minimumCapacity));        &#125;    &#125;    <span class="hljs-comment">//内部数组最大长度，防止 outOfMemoryException</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;    <span class="hljs-comment">//根据给定最小值，获取数组大小并返回</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-comment">// overflow-conscious code，2倍加2</span>        <span class="hljs-keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;        <span class="hljs-comment">//此处选择较大的值进行赋值</span>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;            newCapacity = minCapacity;        &#125;        <span class="hljs-comment">//过小或者过大进行hugeCapacity，否则使用给定值</span>        <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)            ? hugeCapacity(minCapacity)            : newCapacity;    &#125;    <span class="hljs-comment">//处理上述极值情况</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-comment">//超过Integer最大值则抛出异常</span>        <span class="hljs-keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();        &#125;        <span class="hljs-comment">//选取较大的一个值返回</span>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)            ? minCapacity : MAX_ARRAY_SIZE;    &#125;    <span class="hljs-comment">//去除未使用空间</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (count &lt; value.length) &#123;            value = Arrays.copyOf(value, count);        &#125;    &#125;    <span class="hljs-comment">//设置长度大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newLength)</span> </span>&#123;        <span class="hljs-keyword">if</span> (newLength &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(newLength);        <span class="hljs-comment">//此处确保数组容量满足新长度，不足会进行扩容</span>        ensureCapacityInternal(newLength);        <span class="hljs-keyword">if</span> (count &lt; newLength) &#123;            <span class="hljs-comment">//超过长度范围进行补'\0'</span>            Arrays.fill(value, count, newLength, <span class="hljs-string">'\0'</span>);        &#125;        count = newLength;    &#125;    <span class="hljs-comment">//返回给定下标的值(char类型)</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        <span class="hljs-keyword">return</span> value[index];    &#125;    <span class="hljs-comment">//返回给定下标ASCII码值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        &#125;        <span class="hljs-keyword">return</span> Character.codePointAtImpl(value, index, count);    &#125;    <span class="hljs-comment">//返回给定下标之前的码值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointBefore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> ((i &lt; <span class="hljs-number">0</span>) || (i &gt;= count)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        &#125;        <span class="hljs-keyword">return</span> Character.codePointBeforeImpl(value, index, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//计数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span> || endIndex &gt; count || beginIndex &gt; endIndex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();        &#125;        <span class="hljs-keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex-beginIndex);    &#125;    <span class="hljs-comment">//偏移量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> codePointOffset)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();        &#125;        <span class="hljs-keyword">return</span> Character.offsetByCodePointsImpl(value, <span class="hljs-number">0</span>, count,                                                index, codePointOffset);    &#125;    <span class="hljs-comment">//字符数组复制</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcBegin, <span class="hljs-keyword">int</span> srcEnd, <span class="hljs-keyword">char</span>[] dst, <span class="hljs-keyword">int</span> dstBegin)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> (srcBegin &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcBegin);        <span class="hljs-keyword">if</span> ((srcEnd &lt; <span class="hljs-number">0</span>) || (srcEnd &gt; count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcEnd);        <span class="hljs-keyword">if</span> (srcBegin &gt; srcEnd)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(<span class="hljs-string">"srcBegin &gt; srcEnd"</span>);        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);    &#125;    <span class="hljs-comment">//制定下标赋值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span> ch)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        value[index] = ch;    &#125;    <span class="hljs-comment">//添加对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> append(String.valueOf(obj));    &#125;    <span class="hljs-comment">//新增字符串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">int</span> len = str.length();        <span class="hljs-comment">//确保长度足够添加，不够则进行扩容</span>        ensureCapacityInternal(count + len);        <span class="hljs-comment">//char数组复制</span>        str.getChars(<span class="hljs-number">0</span>, len, value, count);        <span class="hljs-comment">//更新当前数组已用长度</span>        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//尾部添加StringBuffer串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(StringBuffer sb)</span> </span>&#123;        <span class="hljs-keyword">if</span> (sb == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">int</span> len = sb.length();        ensureCapacityInternal(count + len);        sb.getChars(<span class="hljs-number">0</span>, len, value, count);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//尾部添加AbstractStringBuilder串</span>    <span class="hljs-function">AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(AbstractStringBuilder asb)</span> </span>&#123;        <span class="hljs-keyword">if</span> (asb == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">int</span> len = asb.length();        ensureCapacityInternal(count + len);        asb.getChars(<span class="hljs-number">0</span>, len, value, count);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> appendNull();        <span class="hljs-keyword">if</span> (s <span class="hljs-keyword">instanceof</span> String)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append((String)s);        <span class="hljs-keyword">if</span> (s <span class="hljs-keyword">instanceof</span> AbstractStringBuilder)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append((AbstractStringBuilder)s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append(s, <span class="hljs-number">0</span>, s.length());    &#125;    <span class="hljs-comment">//添加空值</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> AbstractStringBuilder <span class="hljs-title">appendNull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> c = count;        ensureCapacityInternal(c + <span class="hljs-number">4</span>);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;        value[c++] = <span class="hljs-string">'n'</span>;        value[c++] = <span class="hljs-string">'u'</span>;        value[c++] = <span class="hljs-string">'l'</span>;        value[c++] = <span class="hljs-string">'l'</span>;        count = c;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-comment">//添加串的指定位置</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            s = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">if</span> ((start &lt; <span class="hljs-number">0</span>) || (start &gt; end) || (end &gt; s.length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(                <span class="hljs-string">"start "</span> + start + <span class="hljs-string">", end "</span> + end + <span class="hljs-string">", s.length() "</span>                + s.length());        <span class="hljs-keyword">int</span> len = end - start;        ensureCapacityInternal(count + len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start, j = count; i &lt; end; i++, j++)            value[j] = s.charAt(i);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//添加字符数组</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = str.length;        ensureCapacityInternal(count + len);        System.arraycopy(str, <span class="hljs-number">0</span>, value, count, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)                <span class="hljs-comment">// let arraycopy report AIOOBE for len &lt; 0</span>            ensureCapacityInternal(count + len);        System.arraycopy(str, offset, value, count, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span> (b) &#123;            ensureCapacityInternal(count + <span class="hljs-number">4</span>);            value[count++] = <span class="hljs-string">'t'</span>;            value[count++] = <span class="hljs-string">'r'</span>;            value[count++] = <span class="hljs-string">'u'</span>;            value[count++] = <span class="hljs-string">'e'</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            ensureCapacityInternal(count + <span class="hljs-number">5</span>);            value[count++] = <span class="hljs-string">'f'</span>;            value[count++] = <span class="hljs-string">'a'</span>;            value[count++] = <span class="hljs-string">'l'</span>;            value[count++] = <span class="hljs-string">'s'</span>;            value[count++] = <span class="hljs-string">'e'</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        ensureCapacityInternal(count + <span class="hljs-number">1</span>);        value[count++] = c;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-comment">//添加int数值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-comment">//最值判断</span>        <span class="hljs-keyword">if</span> (i == Integer.MIN_VALUE) &#123;            append(<span class="hljs-string">"-2147483648"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-keyword">int</span> appendedLength = (i &lt; <span class="hljs-number">0</span>) ? Integer.stringSize(-i) + <span class="hljs-number">1</span>                                     : Integer.stringSize(i);        <span class="hljs-keyword">int</span> spaceNeeded = count + appendedLength;        ensureCapacityInternal(spaceNeeded);        Integer.getChars(i, spaceNeeded, value);        count = spaceNeeded;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == Long.MIN_VALUE) &#123;            append(<span class="hljs-string">"-9223372036854775808"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-keyword">int</span> appendedLength = (l &lt; <span class="hljs-number">0</span>) ? Long.stringSize(-l) + <span class="hljs-number">1</span>                                     : Long.stringSize(l);        <span class="hljs-keyword">int</span> spaceNeeded = count + appendedLength;        ensureCapacityInternal(spaceNeeded);        Long.getChars(l, spaceNeeded, value);        count = spaceNeeded;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f)</span> </span>&#123;        FloatingDecimal.appendTo(f,<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;        FloatingDecimal.appendTo(d,<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);        <span class="hljs-keyword">if</span> (end &gt; count)            end = count;        <span class="hljs-keyword">if</span> (start &gt; end)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException();        <span class="hljs-keyword">int</span> len = end - start;        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;            System.arraycopy(value, start+len, value, start, count-end);            count -= len;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">appendCodePoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> codePoint)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = <span class="hljs-keyword">this</span>.count;        <span class="hljs-keyword">if</span> (Character.isBmpCodePoint(codePoint)) &#123;            ensureCapacityInternal(count + <span class="hljs-number">1</span>);            value[count] = (<span class="hljs-keyword">char</span>) codePoint;            <span class="hljs-keyword">this</span>.count = count + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isValidCodePoint(codePoint)) &#123;            ensureCapacityInternal(count + <span class="hljs-number">2</span>);            Character.toSurrogates(codePoint, value, count);            <span class="hljs-keyword">this</span>.count = count + <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//删除其中某一个字符，本质是数组的平移</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">deleteCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        System.arraycopy(value, index+<span class="hljs-number">1</span>, value, index, count-index-<span class="hljs-number">1</span>);        count--;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//替换指定位置字符串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, String str)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);        <span class="hljs-keyword">if</span> (start &gt; count)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(<span class="hljs-string">"start &gt; length()"</span>);        <span class="hljs-keyword">if</span> (start &gt; end)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(<span class="hljs-string">"start &gt; end"</span>);        <span class="hljs-keyword">if</span> (end &gt; count)            end = count;        <span class="hljs-keyword">int</span> len = str.length();        <span class="hljs-keyword">int</span> newCount = count + len - (end - start);        ensureCapacityInternal(newCount);        System.arraycopy(value, end, value, start + len, count - end);        str.getChars(value, start);        count = newCount;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//字符切割</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">return</span> substring(start, count);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharSequence <span class="hljs-title">subSequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">return</span> substring(start, end);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);        <span class="hljs-keyword">if</span> (end &gt; count)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end);        <span class="hljs-keyword">if</span> (start &gt; end)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end - start);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, start, end - start);    &#125;    <span class="hljs-comment">//字符插入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt; length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (len &lt; <span class="hljs-number">0</span>) || (offset &gt; str.length - len))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(                <span class="hljs-string">"offset "</span> + offset + <span class="hljs-string">", len "</span> + len + <span class="hljs-string">", str.length "</span>                + str.length);        ensureCapacityInternal(count + len);        System.arraycopy(value, index, value, index + len, count - index);        System.arraycopy(str, offset, value, index, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, Object obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(obj));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, String str)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (offset &gt; length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)            str = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">int</span> len = str.length();        <span class="hljs-comment">//扩容</span>        ensureCapacityInternal(count + len);        <span class="hljs-comment">//offset开始字符插入 value的len长度之后</span>        System.arraycopy(value, offset, value, offset + len, count - offset);        <span class="hljs-comment">//空出空间存放str</span>        str.getChars(value, offset);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (offset &gt; length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        <span class="hljs-keyword">int</span> len = str.length;        ensureCapacityInternal(count + len);        System.arraycopy(value, offset, value, offset + len, count - offset);        System.arraycopy(str, <span class="hljs-number">0</span>, value, offset, len);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            s = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">if</span> (s <span class="hljs-keyword">instanceof</span> String)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.insert(dstOffset, (String)s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.insert(dstOffset, s, <span class="hljs-number">0</span>, s.length());    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s,</span></span><span class="hljs-function"><span class="hljs-params">                                         <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>)            s = <span class="hljs-string">"null"</span>;        <span class="hljs-keyword">if</span> ((dstOffset &lt; <span class="hljs-number">0</span>) || (dstOffset &gt; <span class="hljs-keyword">this</span>.length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"dstOffset "</span>+dstOffset);        <span class="hljs-keyword">if</span> ((start &lt; <span class="hljs-number">0</span>) || (end &lt; <span class="hljs-number">0</span>) || (start &gt; end) || (end &gt; s.length()))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(                <span class="hljs-string">"start "</span> + start + <span class="hljs-string">", end "</span> + end + <span class="hljs-string">", s.length() "</span>                + s.length());        <span class="hljs-keyword">int</span> len = end - start;        ensureCapacityInternal(count + len);        System.arraycopy(value, dstOffset, value, dstOffset + len,                         count - dstOffset);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)            value[dstOffset++] = s.charAt(i);        count += len;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(b));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span> c)</span> </span>&#123;        ensureCapacityInternal(count + <span class="hljs-number">1</span>);        System.arraycopy(value, offset, value, offset + <span class="hljs-number">1</span>, count - offset);        value[offset] = c;        count += <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(i));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">long</span> l)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(l));    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">float</span> f)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(f));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">double</span> d)</span> </span>&#123;        <span class="hljs-keyword">return</span> insert(offset, String.valueOf(d));    &#125;    <span class="hljs-comment">//获取str首次出现的下标</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(str, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//调用Str数组的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> String.indexOf(value, <span class="hljs-number">0</span>, count, str, fromIndex);    &#125;        <span class="hljs-comment">//获取最后出现位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> lastIndexOf(str, count);    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> String.lastIndexOf(value, <span class="hljs-number">0</span>, count, str, fromIndex);    &#125;    <span class="hljs-comment">//字符数组反转</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">boolean</span> hasSurrogates = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> n = count - <span class="hljs-number">1</span>;        <span class="hljs-comment">//从中间开始左右反转</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = (n-<span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;            <span class="hljs-keyword">int</span> k = n - j;            <span class="hljs-keyword">char</span> cj = value[j];            <span class="hljs-keyword">char</span> ck = value[k];            value[j] = ck;            value[k] = cj;            <span class="hljs-comment">//存在编码</span>            <span class="hljs-keyword">if</span> (Character.isSurrogate(cj) ||                Character.isSurrogate(ck)) &#123;                hasSurrogates = <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-comment">//相关编码进行翻转</span>        <span class="hljs-keyword">if</span> (hasSurrogates) &#123;            reverseAllValidSurrogatePairs();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseAllValidSurrogatePairs</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">char</span> c2 = value[i];            <span class="hljs-keyword">if</span> (Character.isLowSurrogate(c2)) &#123;                <span class="hljs-keyword">char</span> c1 = value[i + <span class="hljs-number">1</span>];                <span class="hljs-keyword">if</span> (Character.isHighSurrogate(c1)) &#123;                    value[i++] = c1;                    value[i] = c2;                &#125;            &#125;        &#125;    &#125;       <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Needed by &#123;<span class="hljs-doctag">@code</span> String&#125; for the contentEquals method.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] getValue() &#123;        <span class="hljs-keyword">return</span> value;    &#125;&#125;</code></pre></li></ul><ul><li>StringBuffer类<pre><code class="hljs java">     <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuffer</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStringBuilder</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">CharSequence</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-comment">//缓存数组，当值变动时修改</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">char</span>[] toStringCache;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3388685877147921107L</span>;    <span class="hljs-comment">//初始化，默认大小16</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        <span class="hljs-keyword">super</span>(capacity);    &#125;    <span class="hljs-comment">//带值初始化时，大小为16+串长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">super</span>(str.length() + <span class="hljs-number">16</span>);        append(str);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(CharSequence seq)</span> </span>&#123;        <span class="hljs-keyword">this</span>(seq.length() + <span class="hljs-number">16</span>);        append(seq);    &#125;        <span class="hljs-comment">//同步方法，获取长度</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;        <span class="hljs-comment">//同步方法，获取容量</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value.length;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;        <span class="hljs-keyword">super</span>.ensureCapacity(minimumCapacity);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.trimToSize();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newLength)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.setLength(newLength);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        <span class="hljs-keyword">return</span> value[index];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.codePointAt(index);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointBefore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.codePointBefore(index);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.codePointCount(beginIndex, endIndex);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> codePointOffset)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.offsetByCodePoints(index, codePointOffset);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcBegin, <span class="hljs-keyword">int</span> srcEnd, <span class="hljs-keyword">char</span>[] dst,</span></span><span class="hljs-function"><span class="hljs-params">                                      <span class="hljs-keyword">int</span> dstBegin)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">super</span>.getChars(srcBegin, srcEnd, dst, dstBegin);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span> ch)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        toStringCache = <span class="hljs-keyword">null</span>;        value[index] = ch;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(String.valueOf(obj));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(StringBuffer sb)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(sb);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(AbstractStringBuilder asb)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(asb);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Appends the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; to this</span><span class="hljs-comment">     * sequence.</span><span class="hljs-comment">     * &lt;p&gt;</span><span class="hljs-comment">     * The characters of the &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; argument are appended,</span><span class="hljs-comment">     * in order, increasing the length of this sequence by the length of the</span><span class="hljs-comment">     * argument.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;The result of this method is exactly the same as if it were an</span><span class="hljs-comment">     * invocation of this.append(s, 0, s.length());</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;This method synchronizes on &#123;<span class="hljs-doctag">@code</span> this&#125;, the destination</span><span class="hljs-comment">     * object, but does not synchronize on the source (&#123;<span class="hljs-doctag">@code</span> s&#125;).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;If &#123;<span class="hljs-doctag">@code</span> s&#125; is &#123;<span class="hljs-doctag">@code</span> null&#125;, then the four characters</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> "null"&#125; are appended.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   s the &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; to append.</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  a reference to this object.</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function">    </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(s, start, end);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(str, offset, len);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(b);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(c);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(i);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">appendCodePoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> codePoint)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.appendCodePoint(codePoint);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lng)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(lng);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(f);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.append(d);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.delete(start, end);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">deleteCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.deleteCharAt(index);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, String str)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.replace(start, end, str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">return</span> substring(start, count);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> CharSequence <span class="hljs-title">subSequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.substring(start, end);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.substring(start, end);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset,</span></span><span class="hljs-function"><span class="hljs-params">                                            <span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function">    </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.insert(index, str, offset, len);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, Object obj)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.insert(offset, String.valueOf(obj));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, String str)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.insert(offset, str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span>[] str)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.insert(offset, str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span>        <span class="hljs-comment">// after narrowing of s to specific type</span>        <span class="hljs-comment">// Ditto for toStringCache clearing</span>        <span class="hljs-keyword">super</span>.insert(dstOffset, s);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function">    </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.insert(dstOffset, s, start, end);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span>  StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span>        <span class="hljs-comment">// after conversion of b to String by super class method</span>        <span class="hljs-comment">// Ditto for toStringCache clearing</span>        <span class="hljs-keyword">super</span>.insert(offset, b);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span> c)</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.insert(offset, c);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span>        <span class="hljs-comment">// after conversion of i to String by super class method</span>        <span class="hljs-comment">// Ditto for toStringCache clearing</span>        <span class="hljs-keyword">super</span>.insert(offset, i);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">long</span> l)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span>        <span class="hljs-comment">// after conversion of l to String by super class method</span>        <span class="hljs-comment">// Ditto for toStringCache clearing</span>        <span class="hljs-keyword">super</span>.insert(offset, l);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">float</span> f)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span>        <span class="hljs-comment">// after conversion of f to String by super class method</span>        <span class="hljs-comment">// Ditto for toStringCache clearing</span>        <span class="hljs-keyword">super</span>.insert(offset, f);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">double</span> d)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span>        <span class="hljs-comment">// after conversion of d to String by super class method</span>        <span class="hljs-comment">// Ditto for toStringCache clearing</span>        <span class="hljs-keyword">super</span>.insert(offset, d);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.indexOf(str);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.indexOf(str, fromIndex);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span>        <span class="hljs-keyword">return</span> lastIndexOf(str, count);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.lastIndexOf(str, fromIndex);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>   JDK1.0.2</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>&#123;        toStringCache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">super</span>.reverse();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-keyword">null</span>) &#123;            toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(toStringCache, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">//序列化相关方法</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields =    &#123;        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">"value"</span>, <span class="hljs-keyword">char</span>[]<span class="hljs-class">.<span class="hljs-keyword">class</span>),</span>        new java.io.ObjectStreamField("count", Integer.TYPE),        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">"shared"</span>, Boolean.TYPE),    &#125;;       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException </span>&#123;        java.io.ObjectOutputStream.PutField fields = s.putFields();        fields.put(<span class="hljs-string">"value"</span>, value);        fields.put(<span class="hljs-string">"count"</span>, count);        fields.put(<span class="hljs-string">"shared"</span>, <span class="hljs-keyword">false</span>);        s.writeFields();    &#125;       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;        java.io.ObjectInputStream.GetField fields = s.readFields();        value = (<span class="hljs-keyword">char</span>[])fields.get(<span class="hljs-string">"value"</span>, <span class="hljs-keyword">null</span>);        count = fields.get(<span class="hljs-string">"count"</span>, <span class="hljs-number">0</span>);    &#125;&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>StringBuffer类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String类探究</title>
    <link href="/2020/11/06/string/"/>
    <url>/2020/11/06/string/</url>
    
    <content type="html"><![CDATA[<h1 id="String类探究"><a href="#String类探究" class="headerlink" title="String类探究"></a>String类探究</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>final类，不可变，不可继承</li><li>底层基于char数组实现（final)，所以不可变</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li><p>String s = new String(“aaa”)</p><ol><li>“aaa”会在常量池创建一个字符串，如果没有则会创建</li><li>String s 会在栈区创建一个引用指针，指向后续new创建的对象</li><li>new String(xxx) 此处调用字符串类型的复制方法,开辟堆内存，本质是是将常亮串的字符数组赋值给此处new的对象</li><li><img src="/images/java/string-memory.png" srcset="/img/loading.gif" alt="avatar"></li></ol></li><li><p>String.intern()</p><pre><code class="hljs html">此方法返回格式化的引用，即返回常量池中的引用，没有的话则会加入常量池</code></pre><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4></li></ul><pre><code class="hljs java"><span class="hljs-comment">//final类，不可继承</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;       <span class="hljs-comment">//核心字符数组，存储字符串中的值</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];    <span class="hljs-comment">//哈希code码值</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span>    <span class="hljs-comment">//序列化UUID</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">6849794470754667710L</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectStreamField[] serialPersistentFields =        <span class="hljs-keyword">new</span> ObjectStreamField[<span class="hljs-number">0</span>];    <span class="hljs-comment">//初始化方法，将空串的数组赋值给当前对象的字符串数组</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = <span class="hljs-string">""</span>.value;    &#125;    <span class="hljs-comment">//带参数的初始化方式，除了进行数组赋值，还进行哈希赋值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(String original)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = original.value;        <span class="hljs-keyword">this</span>.hash = original.hash;    &#125;    <span class="hljs-comment">//通过字符数组初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[])</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = Arrays.copyOf(value, value.length);    &#125;    <span class="hljs-comment">//指定起始位置，和长度初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        &#125;        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);            &#125;            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">""</span>.value;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);        &#125;        <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);    &#125;    <span class="hljs-comment">//通过字符数组初始化，指定起始位置和长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] codePoints, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        &#125;        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);            &#125;            <span class="hljs-keyword">if</span> (offset &lt;= codePoints.length) &#123;                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">""</span>.value;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> (offset &gt; codePoints.length - count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = offset + count;        <span class="hljs-comment">//确定需要创建的数组长度，加上Unicde编码校验代码点（"/u1234"）</span>        <span class="hljs-keyword">int</span> n = count;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = offset; i &lt; end; i++) &#123;            <span class="hljs-keyword">int</span> c = codePoints[i];            <span class="hljs-comment">//判断是否是Unicode编码代码点</span>            <span class="hljs-keyword">if</span> (Character.isBmpCodePoint(c))                <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">//判断是否是有效数字校验点（这块也要进行加上）</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isValidCodePoint(c))                n++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(Integer.toString(c));        &#125;        <span class="hljs-comment">//不可变字符数组赋值</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] v = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = offset, j = <span class="hljs-number">0</span>; i &lt; end; i++, j++) &#123;            <span class="hljs-keyword">int</span> c = codePoints[i];            <span class="hljs-keyword">if</span> (Character.isBmpCodePoint(c))                <span class="hljs-comment">//普通编码直接赋值</span>                v[j] = (<span class="hljs-keyword">char</span>)c;            <span class="hljs-keyword">else</span>                <span class="hljs-comment">//其他类型，进行转换</span>                Character.toSurrogates(c, v, j++);        &#125;        <span class="hljs-keyword">this</span>.value = v;    &#125;    <span class="hljs-comment">/* Common private utility method used to bounds check the byte array</span><span class="hljs-comment">     * and requested offset &amp; length values used by the String(byte[],..)</span><span class="hljs-comment">     * constructors.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkBounds</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(length);        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        <span class="hljs-keyword">if</span> (offset &gt; bytes.length - length)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + length);    &#125;    <span class="hljs-comment">//通过byte数组进行初始化，并进行对应编码</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> bytes[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length, String charsetName)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;        <span class="hljs-keyword">if</span> (charsetName == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"charsetName"</span>);        <span class="hljs-comment">//边界检查</span>        checkBounds(bytes, offset, length);        <span class="hljs-keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> bytes[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length, Charset charset)</span> </span>&#123;        <span class="hljs-keyword">if</span> (charset == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"charset"</span>);        checkBounds(bytes, offset, length);        <span class="hljs-keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> bytes[], String charsetName)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;        <span class="hljs-keyword">this</span>(bytes, <span class="hljs-number">0</span>, bytes.length, charsetName);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;        <span class="hljs-keyword">this</span>(bytes, <span class="hljs-number">0</span>, bytes.length, charset);    &#125;        <span class="hljs-comment">// 通过byte数组进行初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> bytes[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;        checkBounds(bytes, offset, length);        <span class="hljs-keyword">this</span>.value = StringCoding.decode(bytes, offset, length);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> bytes[])</span> </span>&#123;        <span class="hljs-keyword">this</span>(bytes, <span class="hljs-number">0</span>, bytes.length);    &#125;    <span class="hljs-comment">//通过StringBuffer进行初始化,此处的StringBuffer是线程安全的类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(StringBuffer buffer)</span> </span>&#123;        <span class="hljs-comment">//此处锁住buffer对象，保证初始化时候其他线程无法进行修改，可能是考虑到StringBuffer线程安全</span>        <span class="hljs-keyword">synchronized</span>(buffer) &#123;            <span class="hljs-keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());        &#125;    &#125;    <span class="hljs-comment">//通过StringBuilder进行初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(StringBuilder builder)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());    &#125;    <span class="hljs-comment">//内部初始化方法方法</span>    String(<span class="hljs-keyword">char</span>[] value, <span class="hljs-keyword">boolean</span> share) &#123;        <span class="hljs-comment">// assert share : "unshared not supported";</span>        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-comment">//获取字符串长度，实际是内部数组长度，可包含确认编码校验点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value.length;    &#125;    <span class="hljs-comment">//判断字符串是否为空，即判断内部字符数组是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value.length == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//获取字符串中某个位置的字符</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//边界校验</span>        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= value.length)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        &#125;        <span class="hljs-keyword">return</span> value[index];    &#125;    <span class="hljs-comment">//获取对应下标的ASCII码的10进制值,取出Value数组值后进行转换</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= value.length)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        &#125;        <span class="hljs-keyword">return</span> Character.codePointAtImpl(value, index, value.length);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointBefore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> ((i &lt; <span class="hljs-number">0</span>) || (i &gt;= value.length)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);        &#125;        <span class="hljs-keyword">return</span> Character.codePointBeforeImpl(value, index, <span class="hljs-number">0</span>);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span> || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();        &#125;        <span class="hljs-keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> codePointOffset)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; value.length) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();        &#125;        <span class="hljs-keyword">return</span> Character.offsetByCodePointsImpl(value, <span class="hljs-number">0</span>, value.length,                index, codePointOffset);    &#125;   <span class="hljs-comment">//字符串拷贝</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">char</span> dst[], <span class="hljs-keyword">int</span> dstBegin)</span> </span>&#123;        System.arraycopy(value, <span class="hljs-number">0</span>, dst, dstBegin, value.length);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcBegin, <span class="hljs-keyword">int</span> srcEnd, <span class="hljs-keyword">char</span> dst[], <span class="hljs-keyword">int</span> dstBegin)</span> </span>&#123;        <span class="hljs-keyword">if</span> (srcBegin &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcBegin);        &#125;        <span class="hljs-keyword">if</span> (srcEnd &gt; value.length) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcEnd);        &#125;        <span class="hljs-keyword">if</span> (srcBegin &gt; srcEnd) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);        &#125;        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);    &#125;    <span class="hljs-comment">//根据编码规则获取byte</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getBytes(String charsetName)            <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-keyword">if</span> (charsetName == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">return</span> StringCoding.encode(charsetName, value, <span class="hljs-number">0</span>, value.length);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getBytes(Charset charset) &#123;        <span class="hljs-keyword">if</span> (charset == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">return</span> StringCoding.encode(charset, value, <span class="hljs-number">0</span>, value.length);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getBytes() &#123;        <span class="hljs-keyword">return</span> StringCoding.encode(value, <span class="hljs-number">0</span>, value.length);    &#125;    <span class="hljs-comment">//比较相等，逐步比较两个字符串的字符数组</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;            String anotherString = (String)anObject;            <span class="hljs-keyword">int</span> n = value.length;            <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;                <span class="hljs-keyword">char</span> v1[] = value;                <span class="hljs-keyword">char</span> v2[] = anotherString.value;                <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">if</span> (v1[i] != v2[i])                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                    i++;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contentEquals</span><span class="hljs-params">(StringBuffer sb)</span> </span>&#123;        <span class="hljs-keyword">return</span> contentEquals((CharSequence)sb);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonSyncContentEquals</span><span class="hljs-params">(AbstractStringBuilder sb)</span> </span>&#123;        <span class="hljs-keyword">char</span> v1[] = value;        <span class="hljs-keyword">char</span> v2[] = sb.getValue();        <span class="hljs-keyword">int</span> n = v1.length;        <span class="hljs-keyword">if</span> (n != sb.length()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (v1[i] != v2[i]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//和CharSequence 比较是否相等</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contentEquals</span><span class="hljs-params">(CharSequence cs)</span> </span>&#123;        <span class="hljs-comment">// Argument is a StringBuffer, StringBuilder</span>        <span class="hljs-keyword">if</span> (cs <span class="hljs-keyword">instanceof</span> AbstractStringBuilder) &#123;            <span class="hljs-keyword">if</span> (cs <span class="hljs-keyword">instanceof</span> StringBuffer) &#123;                <span class="hljs-keyword">synchronized</span>(cs) &#123;                   <span class="hljs-keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);            &#125;        &#125;        <span class="hljs-comment">// 字符串类型则直接比较</span>        <span class="hljs-keyword">if</span> (cs <span class="hljs-keyword">instanceof</span> String) &#123;            <span class="hljs-keyword">return</span> equals(cs);        &#125;        <span class="hljs-comment">// 其余情况逐步比较</span>        <span class="hljs-keyword">char</span> v1[] = value;        <span class="hljs-keyword">int</span> n = v1.length;        <span class="hljs-keyword">if</span> (n != cs.length()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (v1[i] != cs.charAt(i)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//忽略大小写方式比较大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equalsIgnoreCase</span><span class="hljs-params">(String anotherString)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == anotherString) ? <span class="hljs-keyword">true</span>                : (anotherString != <span class="hljs-keyword">null</span>)                &amp;&amp; (anotherString.value.length == value.length)                &amp;&amp; regionMatches(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, anotherString, <span class="hljs-number">0</span>, value.length);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(String anotherString)</span> </span>&#123;        <span class="hljs-keyword">int</span> len1 = value.length;        <span class="hljs-keyword">int</span> len2 = anotherString.value.length;        <span class="hljs-keyword">int</span> lim = Math.min(len1, len2);        <span class="hljs-keyword">char</span> v1[] = value;        <span class="hljs-keyword">char</span> v2[] = anotherString.value;        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (k &lt; lim) &#123;            <span class="hljs-keyword">char</span> c1 = v1[k];            <span class="hljs-keyword">char</span> c2 = v2[k];            <span class="hljs-keyword">if</span> (c1 != c2) &#123;                <span class="hljs-keyword">return</span> c1 - c2;            &#125;            k++;        &#125;        <span class="hljs-keyword">return</span> len1 - len2;    &#125;        <span class="hljs-comment">//比较大小</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER                                         = <span class="hljs-keyword">new</span> CaseInsensitiveComparator();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaseInsensitiveComparator</span></span><span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;        <span class="hljs-comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8575799808933029326L</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;            <span class="hljs-keyword">int</span> n1 = s1.length();            <span class="hljs-keyword">int</span> n2 = s2.length();            <span class="hljs-keyword">int</span> min = Math.min(n1, n2);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++) &#123;                <span class="hljs-keyword">char</span> c1 = s1.charAt(i);                <span class="hljs-keyword">char</span> c2 = s2.charAt(i);                <span class="hljs-keyword">if</span> (c1 != c2) &#123;                    c1 = Character.toUpperCase(c1);                    c2 = Character.toUpperCase(c2);                    <span class="hljs-keyword">if</span> (c1 != c2) &#123;                        c1 = Character.toLowerCase(c1);                        c2 = Character.toLowerCase(c2);                        <span class="hljs-keyword">if</span> (c1 != c2) &#123;                            <span class="hljs-comment">// No overflow because of numeric promotion</span>                            <span class="hljs-keyword">return</span> c1 - c2;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> n1 - n2;        &#125;        <span class="hljs-comment">/** Replaces the de-serialized object. */</span>        <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareToIgnoreCase</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> CASE_INSENSITIVE_ORDER.compare(<span class="hljs-keyword">this</span>, str);    &#125;    <span class="hljs-comment">//比较指定部分是否相等</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">regionMatches</span><span class="hljs-params">(<span class="hljs-keyword">int</span> toffset, String other, <span class="hljs-keyword">int</span> ooffset,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">char</span> ta[] = value;        <span class="hljs-keyword">int</span> to = toffset;        <span class="hljs-keyword">char</span> pa[] = other.value;        <span class="hljs-keyword">int</span> po = ooffset;        <span class="hljs-comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> ((ooffset &lt; <span class="hljs-number">0</span>) || (toffset &lt; <span class="hljs-number">0</span>)                || (toffset &gt; (<span class="hljs-keyword">long</span>)value.length - len)                || (ooffset &gt; (<span class="hljs-keyword">long</span>)other.value.length - len)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">while</span> (len-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (ta[to++] != pa[po++]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">regionMatches</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> ignoreCase, <span class="hljs-keyword">int</span> toffset,</span></span><span class="hljs-function"><span class="hljs-params">            String other, <span class="hljs-keyword">int</span> ooffset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">char</span> ta[] = value;        <span class="hljs-keyword">int</span> to = toffset;        <span class="hljs-keyword">char</span> pa[] = other.value;        <span class="hljs-keyword">int</span> po = ooffset;        <span class="hljs-comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> ((ooffset &lt; <span class="hljs-number">0</span>) || (toffset &lt; <span class="hljs-number">0</span>)                || (toffset &gt; (<span class="hljs-keyword">long</span>)value.length - len)                || (ooffset &gt; (<span class="hljs-keyword">long</span>)other.value.length - len)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">while</span> (len-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">char</span> c1 = ta[to++];            <span class="hljs-keyword">char</span> c2 = pa[po++];            <span class="hljs-keyword">if</span> (c1 == c2) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (ignoreCase) &#123;                <span class="hljs-comment">// If characters don't match but case may be ignored,</span>                <span class="hljs-comment">// try converting both characters to uppercase.</span>                <span class="hljs-comment">// If the results match, then the comparison scan should</span>                <span class="hljs-comment">// continue.</span>                <span class="hljs-keyword">char</span> u1 = Character.toUpperCase(c1);                <span class="hljs-keyword">char</span> u2 = Character.toUpperCase(c2);                <span class="hljs-keyword">if</span> (u1 == u2) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-comment">// Unfortunately, conversion to uppercase does not work properly</span>                <span class="hljs-comment">// for the Georgian alphabet, which has strange rules about case</span>                <span class="hljs-comment">// conversion.  So we need to make one last check before</span>                <span class="hljs-comment">// exiting.</span>                <span class="hljs-keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//比较制定开始部分 是否以prefix开始</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix, <span class="hljs-keyword">int</span> toffset)</span> </span>&#123;        <span class="hljs-keyword">char</span> ta[] = value;        <span class="hljs-keyword">int</span> to = toffset;        <span class="hljs-keyword">char</span> pa[] = prefix.value;        <span class="hljs-keyword">int</span> po = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pc = prefix.value.length;        <span class="hljs-comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> ((toffset &lt; <span class="hljs-number">0</span>) || (toffset &gt; value.length - pc)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">while</span> (--pc &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (ta[to++] != pa[po++]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//比较从0开始 是否以prefix开始</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;        <span class="hljs-keyword">return</span> startsWith(prefix, <span class="hljs-number">0</span>);    &#125;        <span class="hljs-comment">//比较是否以 给定后缀结尾</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(String suffix)</span> </span>&#123;        <span class="hljs-keyword">return</span> startsWith(suffix, value.length - suffix.value.length);    &#125;    <span class="hljs-comment">//获取hashCode值，如果是字符串方式，则不会进行计算，其他方式初始化则会进行计算</span>    <span class="hljs-comment">//s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> h = hash;        <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">char</span> val[] = value;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;                h = <span class="hljs-number">31</span> * h + val[i];            &#125;            hash = h;        &#125;        <span class="hljs-keyword">return</span> h;    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(ch, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//从指定下标开始 判断给定字符的位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> max = value.length;        <span class="hljs-keyword">if</span> (fromIndex &lt; <span class="hljs-number">0</span>) &#123;            fromIndex = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fromIndex &gt;= max) &#123;            <span class="hljs-comment">// Note: fromIndex might be near -1&gt;&gt;&gt;1.</span>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;            <span class="hljs-comment">// handle most cases here (ch is a BMP code point or a</span>            <span class="hljs-comment">// negative value (invalid code point))</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;                <span class="hljs-keyword">if</span> (value[i] == ch) &#123;                    <span class="hljs-keyword">return</span> i;                &#125;            &#125;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> indexOfSupplementary(ch, fromIndex);        &#125;    &#125;    <span class="hljs-comment">//处理补充字符的位置</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOfSupplementary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (Character.isValidCodePoint(ch)) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> hi = Character.highSurrogate(ch);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> lo = Character.lowSurrogate(ch);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> max = value.length - <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;                <span class="hljs-keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="hljs-number">1</span>] == lo) &#123;                    <span class="hljs-keyword">return</span> i;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//字符最后的出现的位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch)</span> </span>&#123;        <span class="hljs-keyword">return</span> lastIndexOf(ch, value.length - <span class="hljs-number">1</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;            <span class="hljs-comment">// handle most cases here (ch is a BMP code point or a</span>            <span class="hljs-comment">// negative value (invalid code point))</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;            <span class="hljs-keyword">int</span> i = Math.min(fromIndex, value.length - <span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                <span class="hljs-keyword">if</span> (value[i] == ch) &#123;                    <span class="hljs-keyword">return</span> i;                &#125;            &#125;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> lastIndexOfSupplementary(ch, fromIndex);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOfSupplementary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (Character.isValidCodePoint(ch)) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;            <span class="hljs-keyword">char</span> hi = Character.highSurrogate(ch);            <span class="hljs-keyword">char</span> lo = Character.lowSurrogate(ch);            <span class="hljs-keyword">int</span> i = Math.min(fromIndex, value.length - <span class="hljs-number">2</span>);            <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                <span class="hljs-keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="hljs-number">1</span>] == lo) &#123;                    <span class="hljs-keyword">return</span> i;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//判断字符串的起始位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(str, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(value, <span class="hljs-number">0</span>, value.length,                str.value, <span class="hljs-number">0</span>, str.value.length, fromIndex);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] source, <span class="hljs-keyword">int</span> sourceOffset, <span class="hljs-keyword">int</span> sourceCount,</span></span><span class="hljs-function"><span class="hljs-params">            String target, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(source, sourceOffset, sourceCount,                       target.value, <span class="hljs-number">0</span>, target.value.length,                       fromIndex);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] source, <span class="hljs-keyword">int</span> sourceOffset, <span class="hljs-keyword">int</span> sourceCount,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">char</span>[] target, <span class="hljs-keyword">int</span> targetOffset, <span class="hljs-keyword">int</span> targetCount,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (fromIndex &gt;= sourceCount) &#123;            <span class="hljs-keyword">return</span> (targetCount == <span class="hljs-number">0</span> ? sourceCount : -<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> (fromIndex &lt; <span class="hljs-number">0</span>) &#123;            fromIndex = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> (targetCount == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> fromIndex;        &#125;        <span class="hljs-keyword">char</span> first = target[targetOffset];        <span class="hljs-keyword">int</span> max = sourceOffset + (sourceCount - targetCount);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;            <span class="hljs-comment">/* Look for first character. */</span>            <span class="hljs-keyword">if</span> (source[i] != first) &#123;                <span class="hljs-keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);            &#125;            <span class="hljs-comment">/* Found first character, now look at the rest of v2 */</span>            <span class="hljs-keyword">if</span> (i &lt;= max) &#123;                <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;                <span class="hljs-keyword">int</span> end = j + targetCount - <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = targetOffset + <span class="hljs-number">1</span>; j &lt; end &amp;&amp; source[j]                        == target[k]; j++, k++);                <span class="hljs-keyword">if</span> (j == end) &#123;                    <span class="hljs-comment">/* Found whole string. */</span>                    <span class="hljs-keyword">return</span> i - sourceOffset;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">return</span> lastIndexOf(str, value.length);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> lastIndexOf(value, <span class="hljs-number">0</span>, value.length,                str.value, <span class="hljs-number">0</span>, str.value.length, fromIndex);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] source, <span class="hljs-keyword">int</span> sourceOffset, <span class="hljs-keyword">int</span> sourceCount,</span></span><span class="hljs-function"><span class="hljs-params">            String target, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> lastIndexOf(source, sourceOffset, sourceCount,                       target.value, <span class="hljs-number">0</span>, target.value.length,                       fromIndex);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] source, <span class="hljs-keyword">int</span> sourceOffset, <span class="hljs-keyword">int</span> sourceCount,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">char</span>[] target, <span class="hljs-keyword">int</span> targetOffset, <span class="hljs-keyword">int</span> targetCount,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Check arguments; return immediately where possible. For</span><span class="hljs-comment">         * consistency, don't check for null str.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> rightIndex = sourceCount - targetCount;        <span class="hljs-keyword">if</span> (fromIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (fromIndex &gt; rightIndex) &#123;            fromIndex = rightIndex;        &#125;        <span class="hljs-comment">/* Empty string always matches. */</span>        <span class="hljs-keyword">if</span> (targetCount == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> fromIndex;        &#125;        <span class="hljs-keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="hljs-number">1</span>;        <span class="hljs-keyword">char</span> strLastChar = target[strLastIndex];        <span class="hljs-keyword">int</span> min = sourceOffset + targetCount - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> i = min + fromIndex;    startSearchForLastChar:        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;                i--;            &#125;            <span class="hljs-keyword">if</span> (i &lt; min) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> start = j - (targetCount - <span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> k = strLastIndex - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (j &gt; start) &#123;                <span class="hljs-keyword">if</span> (source[j--] != target[k--]) &#123;                    i--;                    <span class="hljs-keyword">continue</span> startSearchForLastChar;                &#125;            &#125;            <span class="hljs-keyword">return</span> start - sourceOffset + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">//字符串分割</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;        <span class="hljs-comment">//边界值判断</span>        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);        &#125;        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);        &#125;        <span class="hljs-comment">//字符串截取</span>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);        &#125;        <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(endIndex);        &#125;        <span class="hljs-keyword">int</span> subLen = endIndex - beginIndex;        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);        &#125;        <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-keyword">this</span>                : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> CharSequence <span class="hljs-title">subSequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.substring(beginIndex, endIndex);    &#125;    <span class="hljs-comment">//字符串拼接</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">concat</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">int</span> otherLen = str.length();        <span class="hljs-keyword">if</span> (otherLen == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-keyword">int</span> len = value.length;        <span class="hljs-comment">//创建新的字符数组，并开辟为存储后续数组的空间</span>        <span class="hljs-keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);        <span class="hljs-comment">//str的字符数组放入buf</span>        str.getChars(buf, len);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf, <span class="hljs-keyword">true</span>);    &#125;        <span class="hljs-comment">//替换其中某个字符</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> oldChar, <span class="hljs-keyword">char</span> newChar)</span> </span>&#123;        <span class="hljs-keyword">if</span> (oldChar != newChar) &#123;            <span class="hljs-keyword">int</span> len = value.length;            <span class="hljs-keyword">int</span> i = -<span class="hljs-number">1</span>;            <span class="hljs-keyword">char</span>[] val = value; <span class="hljs-comment">/* avoid getfield opcode */</span>                        <span class="hljs-comment">//找到旧字符位置</span>            <span class="hljs-keyword">while</span> (++i &lt; len) &#123;                <span class="hljs-keyword">if</span> (val[i] == oldChar) &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (i &lt; len) &#123;                <span class="hljs-comment">//创建新的字符数组并赋值</span>                <span class="hljs-keyword">char</span> buf[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                    buf[j] = val[j];                &#125;                <span class="hljs-comment">//从字符开始进行替换，此处是全部替换</span>                <span class="hljs-keyword">while</span> (i &lt; len) &#123;                    <span class="hljs-keyword">char</span> c = val[i];                    buf[i] = (c == oldChar) ? newChar : c;                    i++;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf, <span class="hljs-keyword">true</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//判断字符串与表达式是否匹配</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(String regex)</span> </span>&#123;        <span class="hljs-keyword">return</span> Pattern.matches(regex, <span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-comment">//判断是否包含,本质是调用indexOf方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(s.toString()) &gt; -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//根据正则式匹配并替换，首次替换</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceFirst</span><span class="hljs-params">(String regex, String replacement)</span> </span>&#123;        <span class="hljs-keyword">return</span> Pattern.compile(regex).matcher(<span class="hljs-keyword">this</span>).replaceFirst(replacement);    &#125;    <span class="hljs-comment">//根据正则式匹配,并全部替换</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceAll</span><span class="hljs-params">(String regex, String replacement)</span> </span>&#123;        <span class="hljs-keyword">return</span> Pattern.compile(regex).matcher(<span class="hljs-keyword">this</span>).replaceAll(replacement);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replace</span><span class="hljs-params">(CharSequence target, CharSequence replacement)</span> </span>&#123;        <span class="hljs-keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(                <span class="hljs-keyword">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));    &#125;    <span class="hljs-comment">//字符串拆分</span>    <span class="hljs-keyword">public</span> String[] split(String regex, <span class="hljs-keyword">int</span> limit) &#123;        <span class="hljs-comment">/* fastpath if the regex is a</span><span class="hljs-comment">         (1)one-char String and this character is not one of the</span><span class="hljs-comment">            RegEx's meta characters ".$|()[&#123;^?*+\\", or</span><span class="hljs-comment">         (2)two-char String and the first char is the backslash and</span><span class="hljs-comment">            the second is not the ascii digit or ascii letter.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">char</span> ch = <span class="hljs-number">0</span>;        <span class="hljs-comment">//正则式匹配</span>        <span class="hljs-keyword">if</span> (((regex.value.length == <span class="hljs-number">1</span> &amp;&amp;             <span class="hljs-string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="hljs-number">0</span>)) == -<span class="hljs-number">1</span>) ||             (regex.length() == <span class="hljs-number">2</span> &amp;&amp;              regex.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'\\'</span> &amp;&amp;              (((ch = regex.charAt(<span class="hljs-number">1</span>))-<span class="hljs-string">'0'</span>)|(<span class="hljs-string">'9'</span>-ch)) &lt; <span class="hljs-number">0</span> &amp;&amp;              ((ch-<span class="hljs-string">'a'</span>)|(<span class="hljs-string">'z'</span>-ch)) &lt; <span class="hljs-number">0</span> &amp;&amp;              ((ch-<span class="hljs-string">'A'</span>)|(<span class="hljs-string">'Z'</span>-ch)) &lt; <span class="hljs-number">0</span>)) &amp;&amp;            (ch &lt; Character.MIN_HIGH_SURROGATE ||             ch &gt; Character.MAX_LOW_SURROGATE))        &#123;            <span class="hljs-keyword">int</span> off = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;            <span class="hljs-keyword">boolean</span> limited = limit &gt; <span class="hljs-number">0</span>;            ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-comment">//进行字符串拆分</span>            <span class="hljs-keyword">while</span> ((next = indexOf(ch, off)) != -<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">if</span> (!limited || list.size() &lt; limit - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">//未到限制份数,继续进行拆分</span>                    list.add(substring(off, next));                    off = next + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// last one</span>                    <span class="hljs-comment">//assert (list.size() == limit - 1);</span>                    <span class="hljs-comment">//到限制次数，此时为最后一个串</span>                    list.add(substring(off, value.length));                    off = value.length;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-comment">//未匹配到正则式，不进行拆分</span>            <span class="hljs-keyword">if</span> (off == <span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-keyword">this</span>&#125;;            <span class="hljs-comment">//未限制，此处增加最后一个串</span>            <span class="hljs-keyword">if</span> (!limited || list.size() &lt; limit)                list.add(substring(off, value.length));            <span class="hljs-comment">// Construct result</span>            <span class="hljs-keyword">int</span> resultSize = list.size();            <span class="hljs-keyword">if</span> (limit == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//获取字符串数组长度</span>                <span class="hljs-keyword">while</span> (resultSize &gt; <span class="hljs-number">0</span> &amp;&amp; list.get(resultSize - <span class="hljs-number">1</span>).length() == <span class="hljs-number">0</span>) &#123;                    resultSize--;                &#125;            &#125;            String[] result = <span class="hljs-keyword">new</span> String[resultSize];            <span class="hljs-keyword">return</span> list.subList(<span class="hljs-number">0</span>, resultSize).toArray(result);        &#125;        <span class="hljs-comment">//表达式长度为多个，或者特殊字符，走Pattern方法</span>        <span class="hljs-keyword">return</span> Pattern.compile(regex).split(<span class="hljs-keyword">this</span>, limit);    &#125;    <span class="hljs-comment">//根据正则式进行拆分，本质调用上一个方法，不进行分割串限制</span>    <span class="hljs-keyword">public</span> String[] split(String regex) &#123;        <span class="hljs-keyword">return</span> split(regex, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//多个字符数组根据表达式合并</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">join</span><span class="hljs-params">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;        Objects.requireNonNull(delimiter);        Objects.requireNonNull(elements);        <span class="hljs-comment">// Number of elements not likely worth Arrays.stream overhead.</span>        StringJoiner joiner = <span class="hljs-keyword">new</span> StringJoiner(delimiter);        <span class="hljs-keyword">for</span> (CharSequence cs: elements) &#123;            joiner.add(cs);        &#125;        <span class="hljs-keyword">return</span> joiner.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">join</span><span class="hljs-params">(CharSequence delimiter,</span></span><span class="hljs-function"><span class="hljs-params">            Iterable&lt;? extends CharSequence&gt; elements)</span> </span>&#123;        Objects.requireNonNull(delimiter);        Objects.requireNonNull(elements);        StringJoiner joiner = <span class="hljs-keyword">new</span> StringJoiner(delimiter);        <span class="hljs-keyword">for</span> (CharSequence cs: elements) &#123;            joiner.add(cs);        &#125;        <span class="hljs-keyword">return</span> joiner.toString();    &#125;    <span class="hljs-comment">//转换为小写</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">(Locale locale)</span> </span>&#123;        <span class="hljs-keyword">if</span> (locale == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        &#125;        <span class="hljs-keyword">int</span> firstUpper;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = value.length;        <span class="hljs-comment">/* Now check if there are any characters that need to be changed. */</span>        scan: &#123;            <span class="hljs-keyword">for</span> (firstUpper = <span class="hljs-number">0</span> ; firstUpper &lt; len; ) &#123;                <span class="hljs-keyword">char</span> c = value[firstUpper];                <span class="hljs-keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)                        &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;                    <span class="hljs-keyword">int</span> supplChar = codePointAt(firstUpper);                    <span class="hljs-keyword">if</span> (supplChar != Character.toLowerCase(supplChar)) &#123;                        <span class="hljs-keyword">break</span> scan;                    &#125;                    firstUpper += Character.charCount(supplChar);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (c != Character.toLowerCase(c)) &#123;                        <span class="hljs-keyword">break</span> scan;                    &#125;                    firstUpper++;                &#125;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-keyword">char</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];        <span class="hljs-keyword">int</span> resultOffset = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* result may grow, so i+resultOffset</span><span class="hljs-comment">                                * is the write location in result */</span>        <span class="hljs-comment">/* Just copy the first few lowerCase characters. */</span>        System.arraycopy(value, <span class="hljs-number">0</span>, result, <span class="hljs-number">0</span>, firstUpper);        String lang = locale.getLanguage();        <span class="hljs-keyword">boolean</span> localeDependent =                (lang == <span class="hljs-string">"tr"</span> || lang == <span class="hljs-string">"az"</span> || lang == <span class="hljs-string">"lt"</span>);        <span class="hljs-keyword">char</span>[] lowerCharArray;        <span class="hljs-keyword">int</span> lowerChar;        <span class="hljs-keyword">int</span> srcChar;        <span class="hljs-keyword">int</span> srcCount;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = firstUpper; i &lt; len; i += srcCount) &#123;            srcChar = (<span class="hljs-keyword">int</span>)value[i];            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE                    &amp;&amp; (<span class="hljs-keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;                srcChar = codePointAt(i);                srcCount = Character.charCount(srcChar);            &#125; <span class="hljs-keyword">else</span> &#123;                srcCount = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span> (localeDependent ||                srcChar == <span class="hljs-string">'\u03A3'</span> || <span class="hljs-comment">// GREEK CAPITAL LETTER SIGMA</span>                srcChar == <span class="hljs-string">'\u0130'</span>) &#123; <span class="hljs-comment">// LATIN CAPITAL LETTER I WITH DOT ABOVE</span>                lowerChar = ConditionalSpecialCasing.toLowerCaseEx(<span class="hljs-keyword">this</span>, i, locale);            &#125; <span class="hljs-keyword">else</span> &#123;                lowerChar = Character.toLowerCase(srcChar);            &#125;            <span class="hljs-keyword">if</span> ((lowerChar == Character.ERROR)                    || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;                <span class="hljs-keyword">if</span> (lowerChar == Character.ERROR) &#123;                    lowerCharArray =                            ConditionalSpecialCasing.toLowerCaseCharArray(<span class="hljs-keyword">this</span>, i, locale);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (srcCount == <span class="hljs-number">2</span>) &#123;                    resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount;                    <span class="hljs-keyword">continue</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    lowerCharArray = Character.toChars(lowerChar);                &#125;                <span class="hljs-comment">/* Grow result if needed */</span>                <span class="hljs-keyword">int</span> mapLen = lowerCharArray.length;                <span class="hljs-keyword">if</span> (mapLen &gt; srcCount) &#123;                    <span class="hljs-keyword">char</span>[] result2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[result.length + mapLen - srcCount];                    System.arraycopy(result, <span class="hljs-number">0</span>, result2, <span class="hljs-number">0</span>, i + resultOffset);                    result = result2;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapLen; ++x) &#123;                    result[i + resultOffset + x] = lowerCharArray[x];                &#125;                resultOffset += (mapLen - srcCount);            &#125; <span class="hljs-keyword">else</span> &#123;                result[i + resultOffset] = (<span class="hljs-keyword">char</span>)lowerChar;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(result, <span class="hljs-number">0</span>, len + resultOffset);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> toLowerCase(Locale.getDefault());    &#125;    <span class="hljs-comment">//转换为大写</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toUpperCase</span><span class="hljs-params">(Locale locale)</span> </span>&#123;        <span class="hljs-keyword">if</span> (locale == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        &#125;        <span class="hljs-keyword">int</span> firstLower;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = value.length;        <span class="hljs-comment">/* Now check if there are any characters that need to be changed. */</span>        scan: &#123;            <span class="hljs-keyword">for</span> (firstLower = <span class="hljs-number">0</span> ; firstLower &lt; len; ) &#123;                <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">int</span>)value[firstLower];                <span class="hljs-keyword">int</span> srcCount;                <span class="hljs-keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)                        &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;                    c = codePointAt(firstLower);                    srcCount = Character.charCount(c);                &#125; <span class="hljs-keyword">else</span> &#123;                    srcCount = <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">int</span> upperCaseChar = Character.toUpperCaseEx(c);                <span class="hljs-keyword">if</span> ((upperCaseChar == Character.ERROR)                        || (c != upperCaseChar)) &#123;                    <span class="hljs-keyword">break</span> scan;                &#125;                firstLower += srcCount;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-comment">/* result may grow, so i+resultOffset is the write location in result */</span>        <span class="hljs-keyword">int</span> resultOffset = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len]; <span class="hljs-comment">/* may grow */</span>        <span class="hljs-comment">/* Just copy the first few upperCase characters. */</span>        System.arraycopy(value, <span class="hljs-number">0</span>, result, <span class="hljs-number">0</span>, firstLower);        String lang = locale.getLanguage();        <span class="hljs-keyword">boolean</span> localeDependent =                (lang == <span class="hljs-string">"tr"</span> || lang == <span class="hljs-string">"az"</span> || lang == <span class="hljs-string">"lt"</span>);        <span class="hljs-keyword">char</span>[] upperCharArray;        <span class="hljs-keyword">int</span> upperChar;        <span class="hljs-keyword">int</span> srcChar;        <span class="hljs-keyword">int</span> srcCount;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = firstLower; i &lt; len; i += srcCount) &#123;            srcChar = (<span class="hljs-keyword">int</span>)value[i];            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp;                (<span class="hljs-keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;                srcChar = codePointAt(i);                srcCount = Character.charCount(srcChar);            &#125; <span class="hljs-keyword">else</span> &#123;                srcCount = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span> (localeDependent) &#123;                upperChar = ConditionalSpecialCasing.toUpperCaseEx(<span class="hljs-keyword">this</span>, i, locale);            &#125; <span class="hljs-keyword">else</span> &#123;                upperChar = Character.toUpperCaseEx(srcChar);            &#125;            <span class="hljs-keyword">if</span> ((upperChar == Character.ERROR)                    || (upperChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;                <span class="hljs-keyword">if</span> (upperChar == Character.ERROR) &#123;                    <span class="hljs-keyword">if</span> (localeDependent) &#123;                        upperCharArray =                                ConditionalSpecialCasing.toUpperCaseCharArray(<span class="hljs-keyword">this</span>, i, locale);                    &#125; <span class="hljs-keyword">else</span> &#123;                        upperCharArray = Character.toUpperCaseCharArray(srcChar);                    &#125;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (srcCount == <span class="hljs-number">2</span>) &#123;                    resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount;                    <span class="hljs-keyword">continue</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    upperCharArray = Character.toChars(upperChar);                &#125;                <span class="hljs-comment">/* Grow result if needed */</span>                <span class="hljs-keyword">int</span> mapLen = upperCharArray.length;                <span class="hljs-keyword">if</span> (mapLen &gt; srcCount) &#123;                    <span class="hljs-keyword">char</span>[] result2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[result.length + mapLen - srcCount];                    System.arraycopy(result, <span class="hljs-number">0</span>, result2, <span class="hljs-number">0</span>, i + resultOffset);                    result = result2;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapLen; ++x) &#123;                    result[i + resultOffset + x] = upperCharArray[x];                &#125;                resultOffset += (mapLen - srcCount);            &#125; <span class="hljs-keyword">else</span> &#123;                result[i + resultOffset] = (<span class="hljs-keyword">char</span>)upperChar;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(result, <span class="hljs-number">0</span>, len + resultOffset);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toUpperCase</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> toUpperCase(Locale.getDefault());    &#125;    <span class="hljs-comment">//去除两边空格,本质进行字符串的分割</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">trim</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> len = value.length;        <span class="hljs-keyword">int</span> st = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span>[] val = value;    <span class="hljs-comment">/* avoid getfield opcode */</span>        <span class="hljs-keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="hljs-string">' '</span>)) &#123;            st++;        &#125;        <span class="hljs-keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">' '</span>)) &#123;            len--;        &#125;        <span class="hljs-keyword">return</span> ((st &gt; <span class="hljs-number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//转换为字符串，返回本身</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//转换为字符数组</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[] toCharArray() &#123;        <span class="hljs-comment">// Cannot use Arrays.copyOf because of class initialization order issues</span>        <span class="hljs-keyword">char</span> result[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[value.length];        System.arraycopy(value, <span class="hljs-number">0</span>, result, <span class="hljs-number">0</span>, value.length);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">//字符串格式化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">format</span><span class="hljs-params">(String format, Object... args)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Formatter().format(format, args).toString();    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">format</span><span class="hljs-params">(Locale l, String format, Object... args)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Formatter(l).format(format, args).toString();    &#125;    <span class="hljs-comment">//转换为字符串</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(Object obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (obj == <span class="hljs-keyword">null</span>) ? <span class="hljs-string">"null"</span> : obj.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data[])</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(data);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(data, offset, count);    &#125;    <span class="hljs-comment">//字符串数据复制</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">copyValueOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(data, offset, count);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">copyValueOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data[])</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(data);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> b ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>;    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;        <span class="hljs-keyword">char</span> data[] = &#123;c&#125;;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(data, <span class="hljs-keyword">true</span>);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> Integer.toString(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;        <span class="hljs-keyword">return</span> Long.toString(l);    &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f)</span> </span>&#123;        <span class="hljs-keyword">return</span> Float.toString(f);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;        <span class="hljs-keyword">return</span> Double.toString(d);    &#125;    <span class="hljs-comment">//返回常量池的引用，如果没有则会加入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">intern</span><span class="hljs-params">()</span></span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于OAuth2和spring-security的token认证的实现</title>
    <link href="/2020/09/27/oauth2/"/>
    <url>/2020/09/27/oauth2/</url>
    
    <content type="html"><![CDATA[<h1 id="基于oauth2和spring-security的token认证的实现"><a href="#基于oauth2和spring-security的token认证的实现" class="headerlink" title="基于oauth2和spring-security的token认证的实现"></a>基于oauth2和spring-security的token认证的实现</h1><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul><li>authenticate: 认证，对用户进行认证</li><li>authorize: 授权，对认证通过的用户授权，颁发票据，用于访问资源服务器</li><li>jwt: 后续访问资源服务器的票据（ticket）</li><li>OAuth2：授权机制的一种，后续实现采用OAuth2中的client credentials方式</li></ul><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><h5 id="对于认证相关请求（登录、刷新token）"><a href="#对于认证相关请求（登录、刷新token）" class="headerlink" title="对于认证相关请求（登录、刷新token）"></a>对于认证相关请求（登录、刷新token）</h5><ul><li>以auth/form为例,此处不会被OAuth2AuthenticationProcessingFilter拦截</li><li>http.form配置的认证拦截器为UsernamePasswordAuthenticationFilter<pre><code class="hljs plain">public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;        &#x2F;&#x2F;校验相关参数        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());        &#125; else &#123;            String username &#x3D; this.obtainUsername(request);            String password &#x3D; this.obtainPassword(request);            if (username &#x3D;&#x3D; null) &#123;                username &#x3D; &quot;&quot;;            &#125;            if (password &#x3D;&#x3D; null) &#123;                password &#x3D; &quot;&quot;;            &#125;            username &#x3D; username.trim();            &#x2F;&#x2F;封装校验信息            UsernamePasswordAuthenticationToken authRequest &#x3D; new UsernamePasswordAuthenticationToken(username, password);            this.setDetails(request, authRequest);            &#x2F;&#x2F;具体认证方法            return this.getAuthenticationManager().authenticate(authRequest);        &#125;    &#125;</code></pre></li><li>ProviderManager中存放多个认证方法provider,会根据filter中存放的认证信息类型，取对应支持的provider进行校验<pre><code class="hljs plain">public Authentication authenticate(Authentication authentication)throws AuthenticationException &#123;        ...        Class&lt;? extends Authentication&gt; toTest &#x3D; authentication.getClass();        ...&#x2F;&#x2F;获取所有provider,逐一比较，支持才进行认证for (AuthenticationProvider provider : getProviders()) &#123;if (!provider.supports(toTest)) &#123;continue;&#125;            try &#123;result &#x3D; provider.authenticate(authentication);if (result !&#x3D; null) &#123;copyDetails(authentication, result);break;&#125;&#125;...        &#x2F;&#x2F;如果还有父类，后续还会进行父类的认证   &#125;&#125;</code></pre></li><li>认证成功和失败之后，会调用各自的处理方法,此处以认证成功的方法进行举例</li></ul><pre><code class="hljs plain">public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;        String header &#x3D; request.getHeader(HttpHeaders.AUTHORIZATION);        if (header &#x3D;&#x3D; null || !header.startsWith(BEARER_TOKEN_TYPE)) &#123;            throw new UnapprovedClientAuthenticationException(&quot;请求头中无client信息&quot;);        &#125;        String[] tokens &#x3D; RequestUtil.extractAndDecodeHeader(header);        assert tokens.length &#x3D;&#x3D; 2;        String clientId &#x3D; tokens[0];        String clientSecret &#x3D; tokens[1];        &#x2F;*验证客户端提供的秘钥*&#x2F;        ClientDetails clientDetails &#x3D; clientDetailsService.loadClientByClientId(clientId);        if (clientDetails &#x3D;&#x3D; null) &#123;            throw new UnapprovedClientAuthenticationException(&quot;clientId对应的配置信息不存在:&quot; + clientId);        &#125; else if (!bCryptPasswordEncoder.matches(clientSecret,clientDetails.getClientSecret())) &#123;            throw new UnapprovedClientAuthenticationException(&quot;clientSecret不匹配:&quot; + clientId);        &#125;                &#x2F;&#x2F;生成OAuth2授权的token        TokenRequest tokenRequest &#x3D; new TokenRequest(new HashMap&lt;&gt;(0), clientId, clientDetails.getScope(), &quot;custom&quot;);        OAuth2Request oAuth2Request &#x3D; tokenRequest.createOAuth2Request(clientDetails);        OAuth2Authentication oAuth2Authentication &#x3D; new OAuth2Authentication(oAuth2Request, authentication);        OAuth2AccessToken token &#x3D; authorizationServerTokenServices.createAccessToken(oAuth2Authentication);        SysUserAuthentication principal &#x3D; (SysUserAuthentication) authentication.getPrincipal();        &#x2F;&#x2F;存储用户信息入redis,为用户注销做准备        userBiz.handlerLoginData(token, principal);        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);        response.getWriter().write((objectMapper.writeValueAsString(ObjectRestResponse.ok(token))));    &#125;</code></pre><h5 id="对于资源请求（请求服务器）"><a href="#对于资源请求（请求服务器）" class="headerlink" title="对于资源请求（请求服务器）"></a>对于资源请求（请求服务器）</h5><ul><li>请求进入filter链，由OAuth2AuthenticationProcessingFilter进行Token校验<pre><code class="hljs plain">public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; ...     Authentication authResult &#x3D; this.authenticationManager.authenticate(authentication);     if (debug) &#123;         logger.debug(&quot;Authentication success: &quot; + authResult);     &#125;          this.eventPublisher.publishAuthenticationSuccess(authResult);     SecurityContextHolder.getContext().setAuthentication(authResult); ...     chain.doFilter(request, response);&#125;</code></pre></li><li>具体认证方法(OAuth2AuthenticationManager管理)<pre><code class="hljs plain">public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;       if (authentication &#x3D;&#x3D; null) &#123;           throw new InvalidTokenException(&quot;Invalid token (token not found)&quot;);       &#125; else &#123;           &#x2F;&#x2F;加载token相关信息           String token &#x3D; (String)authentication.getPrincipal();           &#x2F;&#x2F;此处根据AccessToken获取token相关信息，有兴趣可以单步调试进入，token是否过期也在这个方法里           OAuth2Authentication auth &#x3D; this.tokenServices.loadAuthentication(token);           if (auth &#x3D;&#x3D; null) &#123;               throw new InvalidTokenException(&quot;Invalid token: &quot; + token);           &#125; else &#123;               &#x2F;&#x2F;校验当前客户端ID是否与授权服务器初始化的相匹配               Collection&lt;String&gt; resourceIds &#x3D; auth.getOAuth2Request().getResourceIds();               if (this.resourceId !&#x3D; null &amp;&amp; resourceIds !&#x3D; null &amp;&amp; !resourceIds.isEmpty() &amp;&amp; !resourceIds.contains(this.resourceId)) &#123;                   throw new OAuth2AccessDeniedException(&quot;Invalid token does not contain resource id (&quot; + this.resourceId + &quot;)&quot;);               &#125; else &#123;                   this.checkClientDetails(auth);                   if (authentication.getDetails() instanceof OAuth2AuthenticationDetails) &#123;                       OAuth2AuthenticationDetails details &#x3D; (OAuth2AuthenticationDetails)authentication.getDetails();                       if (!details.equals(auth.getDetails())) &#123;                           details.setDecodedDetails(auth.getDetails());                       &#125;                   &#125;                   auth.setDetails(authentication.getDetails());                   auth.setAuthenticated(true);                   return auth;               &#125;           &#125;       &#125;   &#125;</code></pre></li><li>token认证通过后，则可访问并返回对应接口的数据</li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a><a href="https://github.com/zzzyyyzhuyu/dreamer" target="_blank" rel="noopener">具体实现</a></h4><ul><li>认证相关配置</li><li>授权相关配置</li><li>OAuth2相关配置</li><li>验证码配置</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>配置类中的bean初始化顺序问题，同一个配置类中,@Bean注入的Bean并不一定会在配置方法执行前初始化，尽量把Bean配置单独抽出去作为一个类</li><li>关于用户注销问题：<pre><code class="hljs plain">1.jwt类型的token是无状态的，并不能根据token是否过期来判断用户是否退出登录2.新增用户信息校验和存储，放入redis,在用户退出之后清空，根据token和用户信息联合判断用户的登录状态</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oauth2</tag>
      
      <tag>spring-security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACT_GE_BYTEARRAY 二进制数据流表</title>
    <link href="/2020/06/30/ACT-GE-BYTEARRAY/"/>
    <url>/2020/06/30/ACT-GE-BYTEARRAY/</url>
    
    <content type="html"><![CDATA[<h1 id="ACT-GE-BYTEARRAY-二进制数据流表"><a href="#ACT-GE-BYTEARRAY-二进制数据流表" class="headerlink" title="ACT_GE_BYTEARRAY 二进制数据流表"></a>ACT_GE_BYTEARRAY 二进制数据流表</h1><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>保存流程定义图片和xml、Serializable(序列化)的变量,即保存所有二进制数据</p><h4 id="字段列表"><a href="#字段列表" class="headerlink" title="字段列表"></a>字段列表</h4><table><thead><tr><th align="left">字段名称</th><th align="left">字段描述</th><th align="left">数据类型</th><th align="left">取值说明</th></tr></thead><tbody><tr><td align="left">ID_</td><td align="left">ID_</td><td align="left">nvarchar(64)</td><td align="left">主键ID</td></tr><tr><td align="left">REV_</td><td align="left">乐观锁</td><td align="left">int</td><td align="left">Version(版本)</td></tr><tr><td align="left">NAME_</td><td align="left">名称</td><td align="left">nvarchar(255)</td><td align="left">部署的文件名称，如：leave.bpmn.png,leave.bpmn20.xml</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">DEPLOYMENT_ID_</td><td align="left">部署ID</td><td align="left">nvarchar(64)</td><td align="left">部署表ID</td></tr><tr><td align="left">BYTES_</td><td align="left">字节</td><td align="left">varbinary(max)</td><td align="left">部署文件</td></tr><tr><td align="left">GENERATED_</td><td align="left">是否是引擎生成</td><td align="left">tinyint</td><td align="left">0为用户生成，1为activiti生成</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>工作流相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>activity6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>activity相关表结构介绍</title>
    <link href="/2020/06/24/activityTable/"/>
    <url>/2020/06/24/activityTable/</url>
    
    <content type="html"><![CDATA[<h1 id="表结构说明"><a href="#表结构说明" class="headerlink" title="表结构说明"></a>表结构说明</h1><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul><li>Activiti 使用到的表都是 ACT_ 开头的。表名的第二部分用两个字母表明表的用途。</li><li>ACT_GE_ （GE） 表示 general 全局通用数据及设置，各种情况都使用的数据。</li><li>ACT_HI_ （HI） 表示 history 历史数据表，包含着程执行的历史相关数据，如结束的流程实例，变量，任务，等等</li><li>ACT_ID_ （ID） 表示 identity 组织机构，用户记录，流程中使用到的用户和组。这些表包含标识的信息，如用户，用户组，等等。</li><li>ACT_RE_ （RE） 表示 repository 存储，包含的是静态信息，如，流程定义，流程的资源（图片，规则等）。</li><li>ACT_RU_ （RU） 表示 runtime 运行时，运行时的流程变量，用户任务，变量，职责（job）等运行时的数据。Activiti 只存储实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就保证了这些运行时的表小且快。</li></ul><h4 id="表结构说明-1"><a href="#表结构说明-1" class="headerlink" title="表结构说明"></a>表结构说明</h4><h6 id="一般数据-ACT-GE"><a href="#一般数据-ACT-GE" class="headerlink" title="一般数据(ACT_GE_)"></a>一般数据(ACT_GE_)</h6><table><thead><tr><th align="left">表名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ACT_GE_BYTEARRAY</td><td align="left">二进制数据表，存储通用的流程定义和流程资源</td></tr><tr><td align="left">ACT_GE_PROPERTY</td><td align="left">系统相关属性，属性数据表存储整个流程引擎级别<br>的数据，初始化表结构时，会默认插入三条记录</td></tr></tbody></table><h6 id="流程历史记录-ACI-HI"><a href="#流程历史记录-ACI-HI" class="headerlink" title="流程历史记录(ACI_HI_)"></a>流程历史记录(ACI_HI_)</h6><table><thead><tr><th align="left">表名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ACT_HI_ACTINST</td><td align="left">历史节点表</td></tr><tr><td align="left">ACT_HI_ATTACHMENT</td><td align="left">历史附件表</td></tr><tr><td align="left">ACT_HI_COMMENT</td><td align="left">历史意见表</td></tr><tr><td align="left">ACT_HI_DETAIL</td><td align="left">历史详情表，提供历史变量的查询</td></tr><tr><td align="left">ACT_HI_IDENTITYLINK</td><td align="left">历史流程人员表</td></tr><tr><td align="left">ACT_HI_PROCINST</td><td align="left">历史流程实例表</td></tr><tr><td align="left">ACT_HI_TASKINST</td><td align="left">历史任务实例表</td></tr><tr><td align="left">ACT_HI_VARINST</td><td align="left">历史变量表</td></tr></tbody></table><h6 id="用户用户组表-ACT-ID"><a href="#用户用户组表-ACT-ID" class="headerlink" title="用户用户组表(ACT_ID_ )"></a>用户用户组表(ACT_ID_ )</h6><table><thead><tr><th align="left">表名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ACT_ID_GROUP</td><td align="left">用户组信息表</td></tr><tr><td align="left">ACT_ID_INFO</td><td align="left">用户扩展信息表</td></tr><tr><td align="left">ACT_ID_MEMBERSHIP</td><td align="left">用户与用户组对应信息表</td></tr><tr><td align="left">ACT_ID_USER</td><td align="left">用户信息表</td></tr></tbody></table><h6 id="流程定义表-ACT-RE"><a href="#流程定义表-ACT-RE" class="headerlink" title="流程定义表(ACT_RE_)"></a>流程定义表(ACT_RE_)</h6><table><thead><tr><th align="left">表名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ACT_RE_DEPLOYMENT</td><td align="left">部署信息表</td></tr><tr><td align="left">ACT_RE_MODEL</td><td align="left">流程设计模型部署表</td></tr><tr><td align="left">ACT_RE_PROCDEF</td><td align="left">流程定义数据表</td></tr></tbody></table><h6 id="运行实例表-ACT-RU"><a href="#运行实例表-ACT-RU" class="headerlink" title="运行实例表 (ACT_RU_)"></a>运行实例表 (ACT_RU_)</h6><table><thead><tr><th align="left">表名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ACT_RU_EVENT_SUBSCR</td><td align="left">运行时事件 throwEvent、catchEvent 时间监听信息表</td></tr><tr><td align="left">ACT_RU_EXECUTION</td><td align="left">运行时流程执行实例</td></tr><tr><td align="left">ACT_RU_IDENTITYLINK</td><td align="left">运行时流程人员表，主要存储任务节点与参与者的相关信息</td></tr><tr><td align="left">ACT_RU_JOB</td><td align="left">运行时定时任务数据表</td></tr><tr><td align="left">ACT_RU_TASK</td><td align="left">运行时任务节点表</td></tr><tr><td align="left">ACT_RU_VARIABLE</td><td align="left">运行时流程变量数据表</td></tr></tbody></table><h6 id="其他表"><a href="#其他表" class="headerlink" title="其他表"></a>其他表</h6><table><thead><tr><th align="left">表名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ACT_EVT_LOG</td><td align="left">事件日志</td></tr><tr><td align="left">ACT_PROCDEF_INFO</td><td align="left">流程定义的动态变更信息</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>工作流相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>activity6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态切库的实现</title>
    <link href="/2020/05/25/dynamicDatasource/"/>
    <url>/2020/05/25/dynamicDatasource/</url>
    
    <content type="html"><![CDATA[<h1 id="基于AbstractRoutingDataSource实现动态数据源"><a href="#基于AbstractRoutingDataSource实现动态数据源" class="headerlink" title="基于AbstractRoutingDataSource实现动态数据源"></a>基于AbstractRoutingDataSource实现动态数据源</h1><h4 id="实现思路1："><a href="#实现思路1：" class="headerlink" title="实现思路1："></a>实现思路1：</h4><ul><li>维护一个dataSource,里面放置多个数据源</li><li>abstractRoutingDataSource以下简称RoutingDataSource</li><li>RoutingDataSource中getConnection方法被重写，由getDetermineDataSource决定</li><li>归根结底，由lookUpKey的值，决定获取怎么样的数据源，从而获取连接</li><li>实现：AOP切面动态的判断规则，修改lookUpKey的值，实现多数据源切换</li><li>注：事务可能不支持</li><li>支持分布式事务，需要jta-atomikors</li><li>jta-atomikosDemo地址：<a href="https://github.com/zzzyyyzhuyu/jta-atomikos-demo" target="_blank" rel="noopener">https://github.com/zzzyyyzhuyu/jta-atomikos-demo</a></li></ul><hr><h4 id="RouteingDataSource部分源码"><a href="#RouteingDataSource部分源码" class="headerlink" title="RouteingDataSource部分源码"></a>RouteingDataSource部分源码</h4><pre><code class="hljs plain">package org.springframework.jdbc.datasource.lookup;public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean &#123;        &#x2F;&#x2F;存放数据源集合private Map&lt;Object, Object&gt; targetDataSources;        &#x2F;&#x2F;存放默认数据源private Object defaultTargetDataSource;private boolean lenientFallback &#x3D; true;private DataSourceLookup dataSourceLookup &#x3D; new JndiDataSourceLookup();private Map&lt;Object, DataSource&gt; resolvedDataSources;private DataSource resolvedDefaultDataSource;    &#x2F;&#x2F;设置数据源列表 （key-value,通过key取value）public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) &#123;this.targetDataSources &#x3D; targetDataSources;&#125;    &#x2F;&#x2F;设置默认数据源public void setDefaultTargetDataSource(Object defaultTargetDataSource) &#123;this.defaultTargetDataSource &#x3D; defaultTargetDataSource;&#125;&#x2F;** * Set the DataSourceLookup implementation to use for resolving data source * name Strings in the &#123;@link #setTargetDataSources targetDataSources&#125; map. * &lt;p&gt;Default is a &#123;@link JndiDataSourceLookup&#125;, allowing the JNDI names * of application server DataSources to be specified directly. *&#x2F;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) &#123;this.dataSourceLookup &#x3D; (dataSourceLookup !&#x3D; null ? dataSourceLookup : new JndiDataSourceLookup());&#125;    &#x2F;&#x2F;数据源初始化之后，初始化相关信息@Overridepublic void afterPropertiesSet() &#123;if (this.targetDataSources &#x3D;&#x3D; null) &#123;throw new IllegalArgumentException(&quot;Property &#39;targetDataSources&#39; is required&quot;);&#125;this.resolvedDataSources &#x3D; new HashMap&lt;Object, DataSource&gt;(this.targetDataSources.size());for (Map.Entry&lt;Object, Object&gt; entry : this.targetDataSources.entrySet()) &#123;Object lookupKey &#x3D; resolveSpecifiedLookupKey(entry.getKey());DataSource dataSource &#x3D; resolveSpecifiedDataSource(entry.getValue());this.resolvedDataSources.put(lookupKey, dataSource);&#125;if (this.defaultTargetDataSource !&#x3D; null) &#123;this.resolvedDefaultDataSource &#x3D; resolveSpecifiedDataSource(this.defaultTargetDataSource);&#125;&#125;    &#x2F;&#x2F;获取连接方法，由determineTargetDataSource方法获取数据源@Overridepublic Connection getConnection() throws SQLException &#123;return determineTargetDataSource().getConnection();&#125;        &#x2F;&#x2F;根据当前的lookedUpKey来获取当前数据源protected DataSource determineTargetDataSource() &#123;Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);Object lookupKey &#x3D; determineCurrentLookupKey();DataSource dataSource &#x3D; this.resolvedDataSources.get(lookupKey);if (dataSource &#x3D;&#x3D; null &amp;&amp; (this.lenientFallback || lookupKey &#x3D;&#x3D; null)) &#123;&#x2F;&#x2F;若数据源为空，则取默认数据源dataSource &#x3D; this.resolvedDefaultDataSource;&#125;if (dataSource &#x3D;&#x3D; null) &#123;throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);&#125;return dataSource;&#125;&#x2F;&#x2F;需要重点实现的方法，获取当前lookUpkeyprotected abstract Object determineCurrentLookupKey();</code></pre><h4 id="实现思路2："><a href="#实现思路2：" class="headerlink" title="实现思路2："></a>实现思路2：</h4><ul><li>自己维护多个DataSource</li><li><a href="https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-dynamic-datasource" target="_blank" rel="noopener">详情可参考</a><pre><code class="hljs plain">public class DynamicDataSource extends HikariDataSource &#123;    @Override    public Connection getConnection() throws SQLException &#123;        &#x2F;&#x2F; 获取当前数据源 id        Long id &#x3D; DatasourceConfigContextHolder.getCurrentDatasourceConfig();        &#x2F;&#x2F; 根据当前id获取数据源        HikariDataSource datasource &#x3D; DatasourceHolder.INSTANCE.getDatasource(id);        if (null &#x3D;&#x3D; datasource) &#123;            datasource &#x3D; initDatasource(id);        &#125;        return datasource.getConnection();    &#125;    &#x2F;**     * 初始化数据源     * @param id 数据源id     * @return 数据源     *&#x2F;    private HikariDataSource initDatasource(Long id) &#123;        HikariDataSource dataSource &#x3D; new HikariDataSource();        &#x2F;&#x2F; 判断是否是默认数据源        if (DatasourceHolder.DEFAULT_ID.equals(id)) &#123;            &#x2F;&#x2F; 默认数据源根据 application.yml 配置的生成            DataSourceProperties properties &#x3D; SpringUtil.getBean(DataSourceProperties.class);            dataSource.setJdbcUrl(properties.getUrl());            dataSource.setUsername(properties.getUsername());            dataSource.setPassword(properties.getPassword());            dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);        &#125; else &#123;            &#x2F;&#x2F; 不是默认数据源，通过缓存获取对应id的数据源的配置            DatasourceConfig datasourceConfig &#x3D; DatasourceConfigCache.INSTANCE.getConfig(id);            if (datasourceConfig &#x3D;&#x3D; null) &#123;                throw new RuntimeException(&quot;无此数据源&quot;);            &#125;            dataSource.setJdbcUrl(datasourceConfig.buildJdbcUrl());            dataSource.setUsername(datasourceConfig.getUsername());            dataSource.setPassword(datasourceConfig.getPassword());            dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);        &#125;        &#x2F;&#x2F; 将创建的数据源添加到数据源管理器中，绑定当前线程        DatasourceHolder.INSTANCE.addDatasource(id, dataSource);        return dataSource;    &#125;&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>动态切库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多数据源</tag>
      
      <tag>动态切库</tag>
      
      <tag>jta-atomikos</tag>
      
      <tag>abstractRoutingDataSource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-supervisor</title>
    <link href="/2020/05/22/docker-supervisor/"/>
    <url>/2020/05/22/docker-supervisor/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-supervisor顺序启动jar包"><a href="#docker-supervisor顺序启动jar包" class="headerlink" title="docker+supervisor顺序启动jar包"></a>docker+supervisor顺序启动jar包</h1><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>一个容器内部署多个jar包，jar之间相互依赖的服务，必须有启动先后顺序</li><li>多个进程采用supervisor进行进程管理<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>基于centos/ubantu 配置jdk环境和supervisor环境</li><li>编写supervisor配置文件</li><li>编写dockerfile</li><li>测试运行<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4></li></ol><ul><li><p>supervisor配置文件如下</p><pre><code class="hljs plain"># 配置文件包含目录和进程# 第一段 supervsord 配置软件本身，使用 nodaemon 参数来运行。# 第二段包含要控制的 多个服务。每一段包含一个服务的目录和启动这个服务的命令。# priority为优先级 优先级低的先运行，但不保证执行顺序，可能后启动的先运行起来# startsecs 运行时长xxx后 认为该服务启动成功# startretries 启动失败时重新尝试的次数# 启动说明 eureka -&gt;config -&gt;auth -&gt;getway -&gt; xxxx# 当没有按照顺序启动起来时，会报错然后进行重新启动，在多次尝试之后会按依赖顺序启动[supervisord]nodaemon&#x3D;true[program:dcloud-eureka] command&#x3D;java -jar -Xms256m -Xmx512m &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-eureka.jar &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;priority&#x3D; 2startsecs&#x3D;2[program:dcloud-config] command&#x3D;java -jar -Xms256m -Xmx256m &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-config.jar &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;priority&#x3D;20startsecs&#x3D;60[program:dcloud-auth] command&#x3D;java -jar -Xms512m -Xmx1024m &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-auth.jar  &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;autorestart&#x3D;truepriority&#x3D;30startsecs&#x3D;150startretries&#x3D;100[program:dcloud-gateway] command&#x3D;java -jar -Xms512m -Xmx512m &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-gateway.jar &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;autorestart&#x3D;truepriority&#x3D;40startsecs&#x3D;250startretries&#x3D;100[program:dcloud-base] command&#x3D;java -jar -Xms512m -Xmx1024m &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-base.jar &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;autorestart&#x3D;truepriority&#x3D;80startsecs&#x3D;250startretries&#x3D;100[program:dcloud-data] command&#x3D;java -jar -Xms512m -Xmx1024m &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-data.jar &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;autorestart&#x3D;truepriority&#x3D;100startsecs&#x3D;250startretries&#x3D;100[program:dcloud-server] command&#x3D;java -jar -Xms512m -Xmx1024m &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-server.jar &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1autorestart&#x3D;truepriority&#x3D;200startsecs&#x3D;250startretries&#x3D;100</code></pre></li><li><p>Dockerfile如下（ubantu版本）</p><pre><code class="hljs plain">############################################# version : birdben&#x2F;tools:v1# desc : 当前版本安装的ssh，wget，curl，supervisor ############################################# 设置继承自ubuntu官方镜像FROM ubuntu:14.04# 注意这里要更改系统的时区设置，因为在 web 应用中经常会用到时区这个系统变量，默认的 ubuntu 会让你的应用程序发生不可思议的效果哦ENV DEBIAN_FRONTEND noninteractive# 清空ubuntu更新包 替换源为阿里云的源RUN sudo rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*ADD sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list# 一次性安装vim，wget，curl，ssh server等必备软件# RUN echo &quot;deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu precise main universe&quot;&gt; &#x2F;etc&#x2F;apt&#x2F;sources.listRUN sudo apt-get updateRUN sudo apt-get install -y vim wget curl openssh-server sudo# make a new directory to store the jdk filesRUN mkdir &#x2F;usr&#x2F;local&#x2F;java# copy the jdk  archive to the image,and it will automaticlly unzip the tar fileADD jdk-8u221-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;# make a symbol linkRUN ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_221 &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk# 安装supervisor工具RUN sudo apt-get install -y supervisorRUN sudo mkdir -p &#x2F;var&#x2F;log&#x2F;supervisor# 添加 supervisord 的配置文件，并复制配置文件到对应目录下面。（supervisord.conf文件和Dockerfile文件在同一路径）COPY supervisord.conf &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;supervisord.conf# jar包相关添加COPY dcloud-eureka.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-eureka.jarCOPY dcloud-auth.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-auth.jarCOPY dcloud-data.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-data.jarCOPY dcloud-server.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-server.jarCOPY dcloud-gateway.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-gateway.jarCOPY dcloud-base.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-base.jarCOPY dcloud-config.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-config.jar# set environment variablesENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdkENV JRE_HOME $&#123;JAVA_HOME&#125;&#x2F;jreENV CLASSPATH .:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;libENV PATH $&#123;JAVA_HOME&#125;&#x2F;bin:$PATH# 容器需要开放SSH 22端口EXPOSE 22 60065 60060# 执行supervisord来同时执行多个命令，使用 supervisord 的可执行路径启动服务。CMD [&quot;&#x2F;usr&#x2F;bin&#x2F;supervisord&quot;]</code></pre></li><li><p>centos版本dockerfile</p><pre><code class="hljs plain">############################################# version : birdben&#x2F;tools:v1# desc : 当前版本安装的ssh，wget，curl，supervisor ############################################# 设置继承自centos官方镜像FROM centos:7# 注意这里要更改系统的时区设置，因为在 web 应用中经常会用到时区这个系统变量，默认的 ubuntu 会让你的应用程序发生不可思议的效果哦ENV DEBIAN_FRONTEND noninteractive#升级系统RUN yum -y updateRUN yum  install -y vim wget curlRUN yum  install -y  epel-releaseRUN yum  install -y supervisor# make a new directory to store the jdk filesRUN mkdir &#x2F;usr&#x2F;local&#x2F;java# copy the jdk  archive to the image,and it will automaticlly unzip the tar fileADD jdk-8u221-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;# make a symbol linkRUN ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_221 &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdkRUN  mkdir -p &#x2F;var&#x2F;log&#x2F;supervisor# 添加 supervisord 的配置文件，并复制配置文件到对应目录下面。（supervisord.conf文件和Dockerfile文件在同一路径）COPY supervisord.conf &#x2F;etc&#x2F;supervisord.conf# jar包相关添加COPY dcloud-eureka.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-eureka.jarCOPY dcloud-auth.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-auth.jarCOPY dcloud-data.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-data.jarCOPY dcloud-server.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-server.jarCOPY dcloud-gateway.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-gateway.jarCOPY dcloud-base.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-base.jarCOPY dcloud-config.jar &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;dcloud-config.jarCOPY license.lic &#x2F;usr&#x2F;local&#x2F;docker_files&#x2F;exe&#x2F;license.licCOPY  license.lic   &#x2F;license.lic # set environment variablesENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdkENV JRE_HOME $&#123;JAVA_HOME&#125;&#x2F;jreENV CLASSPATH .:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;libENV PATH $&#123;JAVA_HOME&#125;&#x2F;bin:$PATH# 容器需要开放SSH 22端口EXPOSE 22 60065 60060# 执行supervisord来同时执行多个命令，使用 supervisord 的可执行路径启动服务。CMD [&quot;&#x2F;usr&#x2F;bin&#x2F;supervisord&quot;]</code></pre></li><li><p>换源的文件（防止api-get update失败）sources.list </p></li></ul><pre><code class="hljs plain">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</code></pre><ul><li>Tips<blockquote><p>ubuntu在api-get update时，部分电脑可能会出现 fetch failed,故将ubuntu源替换为阿里云的源</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>容器化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>supervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker compose</title>
    <link href="/2020/05/19/docker-compose/"/>
    <url>/2020/05/19/docker-compose/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-compose初识"><a href="#docker-compose初识" class="headerlink" title="docker compose初识"></a>docker compose初识</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>管理多个docker容器</li><li>简化部署和对多个容器的操作</li><li>单机情况下适用（即容器都在同一个主机）</li></ul><h4 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">安装指南</a></h4><pre><code class="hljs plain">## 1.获取官方镜像sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.24.1&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose## 2.给予权限sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose## 3.添加快捷方式sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose## 4.尝试docker-compose --version</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code class="hljs plain">docker-compose ps  --查看在运行容器列表docker-compose kill --停止容器docker-compose stop --停止容器 servicedocker-compose start --启动容器 servicedocker-compose up  --通过docker-compose.yml启动docker-compose images --查看镜像列表docker-compose build --no-cache xxxx --无缓存式构建镜像</code></pre><h4 id="docker-compose-yml编写"><a href="#docker-compose-yml编写" class="headerlink" title="docker-compose.yml编写"></a><a href="https://blog.csdn.net/Aria_Miazzy/article/details/89326829" target="_blank" rel="noopener">docker-compose.yml编写</a></h4><ul><li>以yy_docker的docker-compose.yml为例<pre><code class="hljs plain">version: &#39;2&#39;#serviece服务列表，以下为各个服务services:  mysql:    ## 镜像名称    image: dcloud_mysql    ## 容器名称    container_name: db_mysql    privileged: true    ## 构建相关    build:      ## 指定相对路径      context: .&#x2F;mysql&#x2F;      ## 指定dockerfile      dockerfile: .&#x2F;Dockerfile    ## 设置意外退出后一致重启      restart: always    ## 对外映射端口号    ports:      - 0.0.0.0:61903:3306    ## 特殊的环境变量参数      environment:        - MYSQL_ROOT_PASSWORD&#x3D;admin123!@#qwe    ## 文件夹映射        volumes:      - .&#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql  redis:    image: dcloud_redis    container_name: db_redis    build:      context: .&#x2F;redis&#x2F;      dockerfile: .&#x2F;Dockerfile    restart: always    ports:      - 0.0.0.0:61904:17328    dcloud:    image: dcloud_api    container_name: dcapi    privileged: true    restart: always    build:      context: .&#x2F;dcloud&#x2F;      dockerfile: .&#x2F;Dockerfile    ports:      - 0.0.0.0:61901:60060      - 0.0.0.0:61902:60065    ## 与其他服务相连接，通过容器名可ping通      links:      - mysql      - redis    ## 依赖关系，后于mysql启动      depends_on:      - mysql  nginx:    image: dcloud_nginx    container_name: dc_nginx    privileged: true    restart: always    build:      context: .&#x2F;nginx&#x2F;      dockerfile: .&#x2F;Dockerfile    ports:      - 0.0.0.0:61905:62052    links:      - mysql      - redis    depends_on:      - dcloud</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>容器化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2020/05/18/docker/"/>
    <url>/2020/05/18/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker初识"><a href="#docker初识" class="headerlink" title="docker初识"></a>docker初识</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源</li><li>与虚拟机类似，但是更加轻量级</li><li>生成docker镜像（image）之后，方便移植到其他机器</li><li>同一个镜像，可以快捷方便启动多次</li></ul><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>image：Docker 镜像（Image），就相当于是一个 root 文件系统，可以本地构建</li><li>container:容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</li><li>DockerHub:镜像中心仓库，自己构建的镜像基本会依赖于基础镜像，本地没有的则会从dockerhub拉取;同时也可以将自己的image发布，供其他人使用</li></ul><h4 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">安装指南</a></h4><pre><code class="hljs plain">## 以centos为例（社区版）#1. 设置docker存储库sudo yum install -y yum-utilssudo yum-config-manager \    --add-repo \    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo#2.安装docker引擎sudo yum install docker-ce docker-ce-cli containerd.io#3.启动docker服务sudo systemctl start docker</code></pre><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre><code class="hljs plain">docker pull xxx  --拉取镜像docker build -t xxx  . --创建镜像docker images  --查看镜像列表docker rmi xxx --删除镜像docker run -d -p 1234:1234  --name myName  imageName  xxx --启动容器  -p 端口 映射 -d 后台运行docker ps -a  --查询正在运行的容器docker stop containerId  --停止某个容器docker rm xxx  -- 移除某个容器docker exec -it xxx bash  --进入相关容器exit -- 退出相关容器docker rm &#96;docker ps -a -q&#96; -- 删除所有容器docker rmi &#96;docker images -q&#96; -- 删除所有镜像docker rmi &#96;docker images -q | awk &#39;&#x2F;^&lt;none&gt;&#x2F; &#123; print $3 &#125;&#39;&#96; -- 删除所有为none的容器docker rmi --force &#96;docker images | grep doss-api | awk &#39;&#123;print $3&#125;&#39;&#96;    &#x2F;&#x2F;其中doss-api为关键字</code></pre><h4 id="dockerHub使用（此处以mysql为例）"><a href="#dockerHub使用（此处以mysql为例）" class="headerlink" title="dockerHub使用（此处以mysql为例）"></a>dockerHub使用（此处以mysql为例）</h4><ul><li>首先从dockerhub迁出mysql镜像,这里以5.7为例</li></ul><pre><code class="hljs plain">docker pull mysql:5.7</code></pre><ul><li><p>部署容器</p><pre><code class="hljs plain">docker run --name mysql57 -e MYSQL_ROOT_PASSWORD&#x3D;123789 -d -p 3307:3306 mysql:tag</code></pre><p>启动mysql镜像，docker run是启动容器的命令；i是交互式操作，t是一个终端，d指的是在后台运行，-P指在本地生成一个随机端口，用来映射mysql的3306端口，mysql指运行mysql镜像.</p></li><li><p>进入容器</p><pre><code class="hljs plain">docker exec -it mysql57 bashmysql -u root -p123456</code></pre><p>如上操作即可访问mysql，如需外网访问需要开放root用户权限</p><pre><code class="hljs plain">mysql&gt; use mysql;mysql&gt; update user set authentication_string &#x3D; password(&#39;123456&#39;) where user &#x3D; &#39;root&#39;;mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;flush privileges;</code></pre><pre><code class="hljs plain">exit --退出容器</code></pre><p>此时即可通过宿主机（docker容器所在服务器）的IP+映射端口访问部署的mysql数据库</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>容器化相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/18/hello-world/"/>
    <url>/2020/05/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
